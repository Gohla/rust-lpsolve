/* automatically generated by rust-bindgen */
#![no_std]
#![allow(bad_style)]

extern crate libc;

pub type lprec = Struct__lprec;
pub enum Struct__INVrec { }
pub type INVrec = Struct__INVrec;
pub enum Union_QSORTrec { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct__B4rec {
    pub B4_var: *mut libc::c_int,
    pub var_B4: *mut libc::c_int,
    pub B4_row: *mut libc::c_int,
    pub row_B4: *mut libc::c_int,
    pub wcol: *mut libc::c_double,
    pub nzwcol: *mut libc::c_int,
}
impl ::core::clone::Clone for Struct__B4rec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__B4rec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type B4rec = Struct__B4rec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__OBJmonrec {
    pub lp: *mut lprec,
    pub oldpivstrategy: libc::c_int,
    pub oldpivrule: libc::c_int,
    pub pivrule: libc::c_int,
    pub ruleswitches: libc::c_int,
    pub limitstall: [libc::c_int; 2usize],
    pub limitruleswitches: libc::c_int,
    pub idxstep: [libc::c_int; 5usize],
    pub countstep: libc::c_int,
    pub startstep: libc::c_int,
    pub currentstep: libc::c_int,
    pub Rcycle: libc::c_int,
    pub Ccycle: libc::c_int,
    pub Ncycle: libc::c_int,
    pub Mcycle: libc::c_int,
    pub Icount: libc::c_int,
    pub thisobj: libc::c_double,
    pub prevobj: libc::c_double,
    pub objstep: [libc::c_double; 5usize],
    pub thisinfeas: libc::c_double,
    pub previnfeas: libc::c_double,
    pub epsvalue: libc::c_double,
    pub spxfunc: [libc::c_char; 10usize],
    pub pivdynamic: libc::c_uchar,
    pub isdual: libc::c_uchar,
    pub active: libc::c_uchar,
}
impl ::core::clone::Clone for Struct__OBJmonrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__OBJmonrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type OBJmonrec = Struct__OBJmonrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__edgerec {
    pub edgeVector: *mut libc::c_double,
}
impl ::core::clone::Clone for Struct__edgerec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__edgerec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type edgerec = Struct__edgerec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__pricerec {
    pub theta: libc::c_double,
    pub pivot: libc::c_double,
    pub epspivot: libc::c_double,
    pub varno: libc::c_int,
    pub lp: *mut lprec,
    pub isdual: libc::c_uchar,
}
impl ::core::clone::Clone for Struct__pricerec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__pricerec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type pricerec = Struct__pricerec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__multirec {
    pub lp: *mut lprec,
    pub size: libc::c_int,
    pub used: libc::c_int,
    pub limit: libc::c_int,
    pub items: *mut pricerec,
    pub freeList: *mut libc::c_int,
    pub sortedList: *mut Union_QSORTrec,
    pub stepList: *mut libc::c_double,
    pub valueList: *mut libc::c_double,
    pub indexSet: *mut libc::c_int,
    pub active: libc::c_int,
    pub retries: libc::c_int,
    pub step_base: libc::c_double,
    pub step_last: libc::c_double,
    pub obj_base: libc::c_double,
    pub obj_last: libc::c_double,
    pub epszero: libc::c_double,
    pub maxpivot: libc::c_double,
    pub maxbound: libc::c_double,
    pub sorted: libc::c_uchar,
    pub truncinf: libc::c_uchar,
    pub objcheck: libc::c_uchar,
    pub dirty: libc::c_uchar,
}
impl ::core::clone::Clone for Struct__multirec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__multirec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type multirec = Struct__multirec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__workarraysrec {
    pub lp: *mut lprec,
    pub size: libc::c_int,
    pub count: libc::c_int,
    pub vectorarray: *mut *mut libc::c_char,
    pub vectorsize: *mut libc::c_int,
}
impl ::core::clone::Clone for Struct__workarraysrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__workarraysrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type workarraysrec = Struct__workarraysrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__LLrec {
    pub size: libc::c_int,
    pub count: libc::c_int,
    pub firstitem: libc::c_int,
    pub lastitem: libc::c_int,
    pub map: *mut libc::c_int,
}
impl ::core::clone::Clone for Struct__LLrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__LLrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type LLrec = Struct__LLrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__PVrec {
    pub count: libc::c_int,
    pub startpos: *mut libc::c_int,
    pub value: *mut libc::c_double,
    pub parent: *mut Struct__PVrec,
}
impl ::core::clone::Clone for Struct__PVrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__PVrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type PVrec = Struct__PVrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__hashelem {
    pub name: *mut libc::c_char,
    pub index: libc::c_int,
    pub next: *mut Struct__hashelem,
    pub nextelem: *mut Struct__hashelem,
}
impl ::core::clone::Clone for Struct__hashelem {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__hashelem {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type hashelem = Struct__hashelem;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub table: *mut *mut hashelem,
    pub size: libc::c_int,
    pub base: libc::c_int,
    pub count: libc::c_int,
    pub first: *mut Struct__hashelem,
    pub last: *mut Struct__hashelem,
}
impl ::core::clone::Clone for Struct_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type hashtable = Struct_Unnamed1;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__MATitem {
    pub rownr: libc::c_int,
    pub colnr: libc::c_int,
    pub value: libc::c_double,
}
impl ::core::clone::Clone for Struct__MATitem {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__MATitem {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type MATitem = Struct__MATitem;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__MATrec {
    pub lp: *mut lprec,
    pub rows: libc::c_int,
    pub columns: libc::c_int,
    pub rows_alloc: libc::c_int,
    pub columns_alloc: libc::c_int,
    pub mat_alloc: libc::c_int,
    pub col_mat_colnr: *mut libc::c_int,
    pub col_mat_rownr: *mut libc::c_int,
    pub col_mat_value: *mut libc::c_double,
    pub col_end: *mut libc::c_int,
    pub col_tag: *mut libc::c_int,
    pub row_mat: *mut libc::c_int,
    pub row_end: *mut libc::c_int,
    pub row_tag: *mut libc::c_int,
    pub colmax: *mut libc::c_double,
    pub rowmax: *mut libc::c_double,
    pub epsvalue: libc::c_double,
    pub infnorm: libc::c_double,
    pub dynrange: libc::c_double,
    pub row_end_valid: libc::c_uchar,
    pub is_roworder: libc::c_uchar,
}
impl ::core::clone::Clone for Struct__MATrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__MATrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type MATrec = Struct__MATrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__DeltaVrec {
    pub lp: *mut lprec,
    pub activelevel: libc::c_int,
    pub tracker: *mut MATrec,
}
impl ::core::clone::Clone for Struct__DeltaVrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__DeltaVrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type DeltaVrec = Struct__DeltaVrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__basisrec {
    pub level: libc::c_int,
    pub var_basic: *mut libc::c_int,
    pub is_basic: *mut libc::c_uchar,
    pub is_lower: *mut libc::c_uchar,
    pub pivots: libc::c_int,
    pub previous: *mut Struct__basisrec,
}
impl ::core::clone::Clone for Struct__basisrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__basisrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type basisrec = Struct__basisrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__presolveundorec {
    pub lp: *mut lprec,
    pub orig_rows: libc::c_int,
    pub orig_columns: libc::c_int,
    pub orig_sum: libc::c_int,
    pub var_to_orig: *mut libc::c_int,
    pub orig_to_var: *mut libc::c_int,
    pub fixed_rhs: *mut libc::c_double,
    pub fixed_obj: *mut libc::c_double,
    pub deletedA: *mut DeltaVrec,
    pub primalundo: *mut DeltaVrec,
    pub dualundo: *mut DeltaVrec,
    pub OFcolsdeleted: libc::c_uchar,
}
impl ::core::clone::Clone for Struct__presolveundorec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__presolveundorec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type presolveundorec = Struct__presolveundorec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__BBPSrec {
    pub lp: *mut lprec,
    pub pseodotype: libc::c_int,
    pub updatelimit: libc::c_int,
    pub updatesfinished: libc::c_int,
    pub restartlimit: libc::c_double,
    pub UPcost: *mut MATitem,
    pub LOcost: *mut MATitem,
    pub secondary: *mut Struct__BBPSrec,
}
impl ::core::clone::Clone for Struct__BBPSrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__BBPSrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type BBPSrec = Struct__BBPSrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__BBrec {
    pub parent: *mut Struct__BBrec,
    pub child: *mut Struct__BBrec,
    pub lp: *mut lprec,
    pub varno: libc::c_int,
    pub vartype: libc::c_int,
    pub lastvarcus: libc::c_int,
    pub lastrcf: libc::c_int,
    pub nodesleft: libc::c_int,
    pub nodessolved: libc::c_int,
    pub nodestatus: libc::c_int,
    pub noderesult: libc::c_double,
    pub lastsolution: libc::c_double,
    pub sc_bound: libc::c_double,
    pub upbo: *mut libc::c_double,
    pub lowbo: *mut libc::c_double,
    pub UPbound: libc::c_double,
    pub LObound: libc::c_double,
    pub UBtrack: libc::c_int,
    pub LBtrack: libc::c_int,
    pub contentmode: libc::c_uchar,
    pub sc_canset: libc::c_uchar,
    pub isSOS: libc::c_uchar,
    pub isGUB: libc::c_uchar,
    pub varmanaged: *mut libc::c_int,
    pub isfloor: libc::c_uchar,
    pub UBzerobased: libc::c_uchar,
}
impl ::core::clone::Clone for Struct__BBrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__BBrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type BBrec = Struct__BBrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__partialrec {
    pub lp: *mut lprec,
    pub blockcount: libc::c_int,
    pub blocknow: libc::c_int,
    pub blockend: *mut libc::c_int,
    pub blockpos: *mut libc::c_int,
    pub isrow: libc::c_uchar,
}
impl ::core::clone::Clone for Struct__partialrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__partialrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type partialrec = Struct__partialrec;
pub type SOSgroup = Struct__SOSgroup;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__SOSrec {
    pub parent: *mut SOSgroup,
    pub tagorder: libc::c_int,
    pub name: *mut libc::c_char,
    pub _type: libc::c_int,
    pub isGUB: libc::c_uchar,
    pub size: libc::c_int,
    pub priority: libc::c_int,
    pub members: *mut libc::c_int,
    pub weights: *mut libc::c_double,
    pub membersSorted: *mut libc::c_int,
    pub membersMapped: *mut libc::c_int,
}
impl ::core::clone::Clone for Struct__SOSrec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__SOSrec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SOSrec = Struct__SOSrec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__SOSgroup {
    pub lp: *mut lprec,
    pub sos_list: *mut *mut SOSrec,
    pub sos_alloc: libc::c_int,
    pub sos_count: libc::c_int,
    pub maxorder: libc::c_int,
    pub sos1_count: libc::c_int,
    pub membership: *mut libc::c_int,
    pub memberpos: *mut libc::c_int,
}
impl ::core::clone::Clone for Struct__SOSgroup {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__SOSgroup {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type lphandle_intfunc =
    unsafe extern "C" fn(lp: *mut lprec,
                         userhandle: *mut libc::c_void)
        -> libc::c_int;
pub type lphandlestr_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         userhandle: *mut libc::c_void,
                         buf: *mut libc::c_char);
pub type lphandleint_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         userhandle: *mut libc::c_void,
                         message: libc::c_int);
pub type lphandleint_intfunc =
    unsafe extern "C" fn(lp: *mut lprec,
                         userhandle: *mut libc::c_void,
                         message: libc::c_int)
        -> libc::c_int;
pub type add_column_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         column: *mut libc::c_double)
        -> libc::c_uchar;
pub type add_columnex_func =
    unsafe extern "C" fn(lp: *mut lprec, count: libc::c_int,
                         column: *mut libc::c_double,
                         rowno: *mut libc::c_int)
        -> libc::c_uchar;
pub type add_constraint_func =
    unsafe extern "C" fn(lp: *mut lprec, row: *mut libc::c_double,
                         constr_type: libc::c_int,
                         rh: libc::c_double)
        -> libc::c_uchar;
pub type add_constraintex_func =
    unsafe extern "C" fn(lp: *mut lprec, count: libc::c_int,
                         row: *mut libc::c_double,
                         colno: *mut libc::c_int,
                         constr_type: libc::c_int,
                         rh: libc::c_double)
        -> libc::c_uchar;
pub type add_lag_con_func =
    unsafe extern "C" fn(lp: *mut lprec, row: *mut libc::c_double,
                         con_type: libc::c_int,
                         rhs: libc::c_double)
        -> libc::c_uchar;
pub type add_SOS_func =
    unsafe extern "C" fn(lp: *mut lprec, name: *mut libc::c_char,
                         sostype: libc::c_int,
                         priority: libc::c_int,
                         count: libc::c_int,
                         sosvars: *mut libc::c_int,
                         weights: *mut libc::c_double)
        -> libc::c_int;
pub type column_in_lp_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         column: *mut libc::c_double)
        -> libc::c_int;
pub type copy_lp_func =
    unsafe extern "C" fn(lp: *mut lprec) -> *mut Struct__lprec;
pub type default_basis_func = unsafe extern "C" fn(lp: *mut lprec);
pub type del_column_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_uchar;
pub type del_constraint_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int)
        -> libc::c_uchar;
pub type delete_lp_func = unsafe extern "C" fn(lp: *mut lprec);
pub type dualize_lp_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type free_lp_func = unsafe extern "C" fn(plp: *mut *mut lprec);
pub type get_anti_degen_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_basis_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         bascolumn: *mut libc::c_int,
                         nonbasic: libc::c_uchar)
        -> libc::c_uchar;
pub type get_basiscrash_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_bb_depthlimit_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_bb_floorfirst_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_bb_rule_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_bounds_tighter_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type get_break_at_value_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_col_name_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> *mut libc::c_char;
pub type get_column_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         column: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_columnex_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         column: *mut libc::c_double,
                         nzrow: *mut libc::c_int)
        -> libc::c_int;
pub type get_constr_type_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int)
        -> libc::c_int;
pub type get_constr_value_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         count: libc::c_int,
                         primsolution: *mut libc::c_double,
                         nzindex: *mut libc::c_int)
        -> libc::c_double;
pub type get_constraints_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         constr: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_dual_solution_func =
    unsafe extern "C" fn(lp: *mut lprec, rc: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_epsb_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_epsd_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_epsel_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_epsint_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_epsperturb_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_epspivot_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_improve_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_infinite_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_lambda_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         lambda: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_lowbo_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_double;
pub type get_lp_index_func =
    unsafe extern "C" fn(lp: *mut lprec, orig_index: libc::c_int)
        -> libc::c_int;
pub type get_lp_name_func =
    unsafe extern "C" fn(lp: *mut lprec) -> *mut libc::c_char;
pub type get_Lrows_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_mat_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         colnr: libc::c_int)
        -> libc::c_double;
pub type get_mat_byindex_func =
    unsafe extern "C" fn(lp: *mut lprec, matindex: libc::c_int,
                         isrow: libc::c_uchar,
                         adjustsign: libc::c_uchar)
        -> libc::c_double;
pub type get_max_level_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_maxpivot_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_mip_gap_func =
    unsafe extern "C" fn(lp: *mut lprec, absolute: libc::c_uchar)
        -> libc::c_double;
pub type get_multiprice_func =
    unsafe extern "C" fn(lp: *mut lprec, getabssize: libc::c_uchar)
        -> libc::c_int;
pub type is_use_names_func =
    unsafe extern "C" fn(lp: *mut lprec, isrow: libc::c_uchar)
        -> libc::c_uchar;
pub type set_use_names_func =
    unsafe extern "C" fn(lp: *mut lprec, isrow: libc::c_uchar,
                         use_names: libc::c_uchar);
pub type get_nameindex_func =
    unsafe extern "C" fn(lp: *mut lprec, varname: *mut libc::c_char,
                         isrow: libc::c_uchar)
        -> libc::c_int;
pub type get_Ncolumns_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_negrange_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_nz_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_Norig_columns_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_Norig_rows_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_Nrows_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_obj_bound_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_objective_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_orig_index_func =
    unsafe extern "C" fn(lp: *mut lprec, lp_index: libc::c_int)
        -> libc::c_int;
pub type get_origcol_name_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> *mut libc::c_char;
pub type get_origrow_name_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int)
        -> *mut libc::c_char;
pub type get_partialprice_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         blockcount: *mut libc::c_int,
                         blockstart: *mut libc::c_int,
                         isrow: libc::c_uchar);
pub type get_pivoting_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_presolve_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_presolveloops_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_primal_solution_func =
    unsafe extern "C" fn(lp: *mut lprec, pv: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_print_sol_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_pseudocosts_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         clower: *mut libc::c_double,
                         cupper: *mut libc::c_double,
                         updatelimit: *mut libc::c_int)
        -> libc::c_uchar;
pub type get_ptr_constraints_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         constr: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_ptr_dual_solution_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         rc: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_ptr_lambda_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         lambda: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_ptr_primal_solution_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         pv: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_ptr_sensitivity_obj_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         objfrom: *mut *mut libc::c_double,
                         objtill: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_ptr_sensitivity_objex_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         objfrom: *mut *mut libc::c_double,
                         objtill: *mut *mut libc::c_double,
                         objfromvalue: *mut *mut libc::c_double,
                         objtillvalue: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_ptr_sensitivity_rhs_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         duals: *mut *mut libc::c_double,
                         dualsfrom: *mut *mut libc::c_double,
                         dualstill: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_ptr_variables_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         var: *mut *mut libc::c_double)
        -> libc::c_uchar;
pub type get_rh_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int)
        -> libc::c_double;
pub type get_rh_range_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int)
        -> libc::c_double;
pub type get_rowex_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         row: *mut libc::c_double,
                         colno: *mut libc::c_int)
        -> libc::c_int;
pub type get_row_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         row: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_row_name_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int)
        -> *mut libc::c_char;
pub type get_scalelimit_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type get_scaling_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_sensitivity_obj_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         objfrom: *mut libc::c_double,
                         objtill: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_sensitivity_objex_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         objfrom: *mut libc::c_double,
                         objtill: *mut libc::c_double,
                         objfromvalue: *mut libc::c_double,
                         objtillvalue: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_sensitivity_rhs_func =
    unsafe extern "C" fn(lp: *mut lprec, duals: *mut libc::c_double,
                         dualsfrom: *mut libc::c_double,
                         dualstill: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_simplextype_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_solutioncount_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_solutionlimit_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_status_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type get_statustext_func =
    unsafe extern "C" fn(lp: *mut lprec, statuscode: libc::c_int)
        -> *mut libc::c_char;
pub type get_timeout_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_long;
pub type get_total_iter_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_longlong;
pub type get_total_nodes_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_longlong;
pub type get_upbo_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_double;
pub type get_var_branch_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_int;
pub type get_var_dualresult_func =
    unsafe extern "C" fn(lp: *mut lprec, index: libc::c_int)
        -> libc::c_double;
pub type get_var_primalresult_func =
    unsafe extern "C" fn(lp: *mut lprec, index: libc::c_int)
        -> libc::c_double;
pub type get_var_priority_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_int;
pub type get_variables_func =
    unsafe extern "C" fn(lp: *mut lprec, var: *mut libc::c_double)
        -> libc::c_uchar;
pub type get_verbose_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type guess_basis_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         guessvector: *mut libc::c_double,
                         basisvector: *mut libc::c_int)
        -> libc::c_uchar;
pub type get_working_objective_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type has_BFP_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type has_XLI_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_add_rowmode_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_anti_degen_func =
    unsafe extern "C" fn(lp: *mut lprec, testmask: libc::c_int)
        -> libc::c_uchar;
pub type is_binary_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_uchar;
pub type is_break_at_first_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_constr_type_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         mask: libc::c_int)
        -> libc::c_uchar;
pub type is_debug_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_feasible_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         values: *mut libc::c_double,
                         threshold: libc::c_double)
        -> libc::c_uchar;
pub type is_unbounded_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_uchar;
pub type is_infinite_func =
    unsafe extern "C" fn(lp: *mut lprec, value: libc::c_double)
        -> libc::c_uchar;
pub type is_int_func =
    unsafe extern "C" fn(lp: *mut lprec, column: libc::c_int)
        -> libc::c_uchar;
pub type is_integerscaling_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_lag_trace_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_maxim_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_nativeBFP_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_nativeXLI_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_negative_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_uchar;
pub type is_obj_in_basis_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type is_piv_mode_func =
    unsafe extern "C" fn(lp: *mut lprec, testmask: libc::c_int)
        -> libc::c_uchar;
pub type is_piv_rule_func =
    unsafe extern "C" fn(lp: *mut lprec, rule: libc::c_int)
        -> libc::c_uchar;
pub type is_presolve_func =
    unsafe extern "C" fn(lp: *mut lprec, testmask: libc::c_int)
        -> libc::c_uchar;
pub type is_scalemode_func =
    unsafe extern "C" fn(lp: *mut lprec, testmask: libc::c_int)
        -> libc::c_uchar;
pub type is_scaletype_func =
    unsafe extern "C" fn(lp: *mut lprec, scaletype: libc::c_int)
        -> libc::c_uchar;
pub type is_semicont_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_uchar;
pub type is_SOS_var_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_uchar;
pub type is_trace_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type lp_solve_version_func =
    unsafe extern "C" fn(majorversion: *mut libc::c_int,
                         minorversion: *mut libc::c_int,
                         release: *mut libc::c_int,
                         build: *mut libc::c_int);
pub type make_lp_func =
    extern "C" fn(rows: libc::c_int, columns: libc::c_int)
        -> *mut Struct__lprec;
pub type print_constraints_func =
    unsafe extern "C" fn(lp: *mut lprec, columns: libc::c_int);
pub type print_debugdump_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type print_duals_func = unsafe extern "C" fn(lp: *mut lprec);
pub type print_lp_func = unsafe extern "C" fn(lp: *mut lprec);
pub type print_objective_func = unsafe extern "C" fn(lp: *mut lprec);
pub type print_scales_func = unsafe extern "C" fn(lp: *mut lprec);
pub type print_solution_func =
    unsafe extern "C" fn(lp: *mut lprec, columns: libc::c_int);
pub type print_str_func =
    unsafe extern "C" fn(lp: *mut lprec, str: *mut libc::c_char);
pub type print_tableau_func = unsafe extern "C" fn(lp: *mut lprec);
pub type put_abortfunc_func =
    unsafe extern "C" fn(lp: *mut lprec, newctrlc: lphandle_intfunc,
                         ctrlchandle: *mut libc::c_void);
pub type put_bb_nodefunc_func =
    unsafe extern "C" fn(lp: *mut lprec, newnode: lphandleint_intfunc,
                         bbnodehandle: *mut libc::c_void);
pub type put_bb_branchfunc_func =
    unsafe extern "C" fn(lp: *mut lprec, newbranch: lphandleint_intfunc,
                         bbbranchhandle: *mut libc::c_void);
pub type put_logfunc_func =
    unsafe extern "C" fn(lp: *mut lprec, newlog: lphandlestr_func,
                         loghandle: *mut libc::c_void);
pub type put_msgfunc_func =
    unsafe extern "C" fn(lp: *mut lprec, newmsg: lphandleint_func,
                         msghandle: *mut libc::c_void,
                         mask: libc::c_int);
pub type read_LP_func =
    unsafe extern "C" fn(filename: *mut libc::c_char,
                         verbose: libc::c_int,
                         lp_name: *mut libc::c_char)
        -> *mut Struct__lprec;
pub type read_MPS_func =
    unsafe extern "C" fn(filename: *mut libc::c_char,
                         options: libc::c_int)
        -> *mut Struct__lprec;
pub type read_XLI_func =
    unsafe extern "C" fn(xliname: *mut libc::c_char,
                         modelname: *mut libc::c_char,
                         dataname: *mut libc::c_char,
                         options: *mut libc::c_char,
                         verbose: libc::c_int)
        -> *mut Struct__lprec;
pub type read_basis_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char,
                         info: *mut libc::c_char)
        -> libc::c_uchar;
pub type reset_basis_func = unsafe extern "C" fn(lp: *mut lprec);
pub type read_params_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char,
                         options: *mut libc::c_char)
        -> libc::c_uchar;
pub type reset_params_func = unsafe extern "C" fn(lp: *mut lprec);
pub type resize_lp_func =
    unsafe extern "C" fn(lp: *mut lprec, rows: libc::c_int,
                         columns: libc::c_int)
        -> libc::c_uchar;
pub type set_add_rowmode_func =
    unsafe extern "C" fn(lp: *mut lprec, turnon: libc::c_uchar)
        -> libc::c_uchar;
pub type set_anti_degen_func =
    unsafe extern "C" fn(lp: *mut lprec, anti_degen: libc::c_int);
pub type set_basisvar_func =
    unsafe extern "C" fn(lp: *mut lprec, basisPos: libc::c_int,
                         enteringCol: libc::c_int)
        -> libc::c_int;
pub type set_basis_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         bascolumn: *mut libc::c_int,
                         nonbasic: libc::c_uchar)
        -> libc::c_uchar;
pub type set_basiscrash_func =
    unsafe extern "C" fn(lp: *mut lprec, mode: libc::c_int);
pub type set_bb_depthlimit_func =
    unsafe extern "C" fn(lp: *mut lprec, bb_maxlevel: libc::c_int);
pub type set_bb_floorfirst_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         bb_floorfirst: libc::c_int);
pub type set_bb_rule_func =
    unsafe extern "C" fn(lp: *mut lprec, bb_rule: libc::c_int);
pub type set_BFP_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type set_binary_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         must_be_bin: libc::c_uchar)
        -> libc::c_uchar;
pub type set_bounds_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         lower: libc::c_double,
                         upper: libc::c_double)
        -> libc::c_uchar;
pub type set_bounds_tighter_func =
    unsafe extern "C" fn(lp: *mut lprec, tighten: libc::c_uchar);
pub type set_break_at_first_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         break_at_first: libc::c_uchar);
pub type set_break_at_value_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         break_at_value: libc::c_double);
pub type set_column_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         column: *mut libc::c_double)
        -> libc::c_uchar;
pub type set_columnex_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         count: libc::c_int,
                         column: *mut libc::c_double,
                         rowno: *mut libc::c_int)
        -> libc::c_uchar;
pub type set_col_name_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         new_name: *mut libc::c_char)
        -> libc::c_uchar;
pub type set_constr_type_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         con_type: libc::c_int)
        -> libc::c_uchar;
pub type set_debug_func =
    unsafe extern "C" fn(lp: *mut lprec, debug: libc::c_uchar);
pub type set_epsb_func =
    unsafe extern "C" fn(lp: *mut lprec, epsb: libc::c_double);
pub type set_epsd_func =
    unsafe extern "C" fn(lp: *mut lprec, epsd: libc::c_double);
pub type set_epsel_func =
    unsafe extern "C" fn(lp: *mut lprec, epsel: libc::c_double);
pub type set_epsint_func =
    unsafe extern "C" fn(lp: *mut lprec, epsint: libc::c_double);
pub type set_epslevel_func =
    unsafe extern "C" fn(lp: *mut lprec, epslevel: libc::c_int)
        -> libc::c_uchar;
pub type set_epsperturb_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         epsperturb: libc::c_double);
pub type set_epspivot_func =
    unsafe extern "C" fn(lp: *mut lprec, epspivot: libc::c_double);
pub type set_unbounded_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int)
        -> libc::c_uchar;
pub type set_improve_func =
    unsafe extern "C" fn(lp: *mut lprec, improve: libc::c_int);
pub type set_infinite_func =
    unsafe extern "C" fn(lp: *mut lprec, infinite: libc::c_double);
pub type set_int_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         must_be_int: libc::c_uchar)
        -> libc::c_uchar;
pub type set_lag_trace_func =
    unsafe extern "C" fn(lp: *mut lprec, lag_trace: libc::c_uchar);
pub type set_lowbo_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         value: libc::c_double)
        -> libc::c_uchar;
pub type set_lp_name_func =
    unsafe extern "C" fn(lp: *mut lprec, lpname: *mut libc::c_char)
        -> libc::c_uchar;
pub type set_mat_func =
    unsafe extern "C" fn(lp: *mut lprec, row: libc::c_int,
                         column: libc::c_int,
                         value: libc::c_double)
        -> libc::c_uchar;
pub type set_maxim_func = unsafe extern "C" fn(lp: *mut lprec);
pub type set_maxpivot_func =
    unsafe extern "C" fn(lp: *mut lprec, max_num_inv: libc::c_int);
pub type set_minim_func = unsafe extern "C" fn(lp: *mut lprec);
pub type set_mip_gap_func =
    unsafe extern "C" fn(lp: *mut lprec, absolute: libc::c_uchar,
                         mip_gap: libc::c_double);
pub type set_multiprice_func =
    unsafe extern "C" fn(lp: *mut lprec, multiblockdiv: libc::c_int)
        -> libc::c_uchar;
pub type set_negrange_func =
    unsafe extern "C" fn(lp: *mut lprec, negrange: libc::c_double);
pub type set_obj_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         value: libc::c_double)
        -> libc::c_uchar;
pub type set_obj_bound_func =
    unsafe extern "C" fn(lp: *mut lprec, obj_bound: libc::c_double);
pub type set_obj_fn_func =
    unsafe extern "C" fn(lp: *mut lprec, row: *mut libc::c_double)
        -> libc::c_uchar;
pub type set_obj_fnex_func =
    unsafe extern "C" fn(lp: *mut lprec, count: libc::c_int,
                         row: *mut libc::c_double,
                         colno: *mut libc::c_int)
        -> libc::c_uchar;
pub type set_obj_in_basis_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         obj_in_basis: libc::c_uchar);
pub type set_outputfile_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type set_outputstream_func =
    unsafe extern "C" fn(lp: *mut lprec, stream: *mut libc::FILE);
pub type set_partialprice_func =
    unsafe extern "C" fn(lp: *mut lprec, blockcount: libc::c_int,
                         blockstart: *mut libc::c_int,
                         isrow: libc::c_uchar)
        -> libc::c_uchar;
pub type set_pivoting_func =
    unsafe extern "C" fn(lp: *mut lprec, piv_rule: libc::c_int);
pub type set_preferdual_func =
    unsafe extern "C" fn(lp: *mut lprec, dodual: libc::c_uchar);
pub type set_presolve_func =
    unsafe extern "C" fn(lp: *mut lprec, presolvemode: libc::c_int,
                         maxloops: libc::c_int);
pub type set_print_sol_func =
    unsafe extern "C" fn(lp: *mut lprec, print_sol: libc::c_int);
pub type set_pseudocosts_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         clower: *mut libc::c_double,
                         cupper: *mut libc::c_double,
                         updatelimit: *mut libc::c_int)
        -> libc::c_uchar;
pub type set_rh_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         value: libc::c_double)
        -> libc::c_uchar;
pub type set_rh_range_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         deltavalue: libc::c_double)
        -> libc::c_uchar;
pub type set_rh_vec_func =
    unsafe extern "C" fn(lp: *mut lprec, rh: *mut libc::c_double);
pub type set_row_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         row: *mut libc::c_double)
        -> libc::c_uchar;
pub type set_rowex_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         count: libc::c_int,
                         row: *mut libc::c_double,
                         colno: *mut libc::c_int)
        -> libc::c_uchar;
pub type set_row_name_func =
    unsafe extern "C" fn(lp: *mut lprec, rownr: libc::c_int,
                         new_name: *mut libc::c_char)
        -> libc::c_uchar;
pub type set_scalelimit_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         scalelimit: libc::c_double);
pub type set_scaling_func =
    unsafe extern "C" fn(lp: *mut lprec, scalemode: libc::c_int);
pub type set_semicont_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         must_be_sc: libc::c_uchar)
        -> libc::c_uchar;
pub type set_sense_func =
    unsafe extern "C" fn(lp: *mut lprec, maximize: libc::c_uchar);
pub type set_simplextype_func =
    unsafe extern "C" fn(lp: *mut lprec, simplextype: libc::c_int);
pub type set_solutionlimit_func =
    unsafe extern "C" fn(lp: *mut lprec, limit: libc::c_int);
pub type set_timeout_func =
    unsafe extern "C" fn(lp: *mut lprec, sectimeout: libc::c_long);
pub type set_trace_func =
    unsafe extern "C" fn(lp: *mut lprec, trace: libc::c_uchar);
pub type set_upbo_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         value: libc::c_double)
        -> libc::c_uchar;
pub type set_var_branch_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         branch_mode: libc::c_int)
        -> libc::c_uchar;
pub type set_var_weights_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         weights: *mut libc::c_double)
        -> libc::c_uchar;
pub type set_verbose_func =
    unsafe extern "C" fn(lp: *mut lprec, verbose: libc::c_int);
pub type set_XLI_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type solve_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type str_add_column_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         col_string: *mut libc::c_char)
        -> libc::c_uchar;
pub type str_add_constraint_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         row_string: *mut libc::c_char,
                         constr_type: libc::c_int,
                         rh: libc::c_double)
        -> libc::c_uchar;
pub type str_add_lag_con_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         row_string: *mut libc::c_char,
                         con_type: libc::c_int,
                         rhs: libc::c_double)
        -> libc::c_uchar;
pub type str_set_obj_fn_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         row_string: *mut libc::c_char)
        -> libc::c_uchar;
pub type str_set_rh_vec_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         rh_string: *mut libc::c_char)
        -> libc::c_uchar;
pub type time_elapsed_func =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type unscale_func = unsafe extern "C" fn(lp: *mut lprec);
pub type write_lp_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type write_LP_func =
    unsafe extern "C" fn(lp: *mut lprec, output: *mut libc::FILE)
        -> libc::c_uchar;
pub type write_mps_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type write_MPS_func =
    unsafe extern "C" fn(lp: *mut lprec, output: *mut libc::FILE)
        -> libc::c_uchar;
pub type write_freemps_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type write_freeMPS_func =
    unsafe extern "C" fn(lp: *mut lprec, output: *mut libc::FILE)
        -> libc::c_uchar;
pub type write_XLI_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char,
                         options: *mut libc::c_char,
                         results: libc::c_uchar)
        -> libc::c_uchar;
pub type write_basis_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char)
        -> libc::c_uchar;
pub type write_params_func =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char,
                         options: *mut libc::c_char)
        -> libc::c_uchar;
pub type userabortfunc =
    unsafe extern "C" fn(lp: *mut lprec, level: libc::c_int)
        -> libc::c_uchar;
pub type reportfunc =
    unsafe extern "C" fn(lp: *mut lprec, level: libc::c_int,
                         format: *mut libc::c_char, ...);
pub type explainfunc =
    unsafe extern "C" fn(lp: *mut lprec,
                         format: *mut libc::c_char, ...)
        -> *mut libc::c_char;
pub type getvectorfunc =
    unsafe extern "C" fn(lp: *mut lprec, varin: libc::c_int,
                         pcol: *mut libc::c_double,
                         nzlist: *mut libc::c_int,
                         maxabs: *mut libc::c_int)
        -> libc::c_int;
pub type getpackedfunc =
    unsafe extern "C" fn(lp: *mut lprec, j: libc::c_int,
                         rn: *mut libc::c_int,
                         bj: *mut libc::c_double)
        -> libc::c_int;
pub type get_OF_activefunc =
    unsafe extern "C" fn(lp: *mut lprec, varnr: libc::c_int,
                         mult: libc::c_double)
        -> libc::c_double;
pub type getMDOfunc =
    unsafe extern "C" fn(lp: *mut lprec,
                         usedpos: *mut libc::c_uchar,
                         colorder: *mut libc::c_int,
                         size: *mut libc::c_int,
                         symmetric: libc::c_uchar)
        -> libc::c_int;
pub type invertfunc =
    unsafe extern "C" fn(lp: *mut lprec, shiftbounds: libc::c_uchar,
                         _final: libc::c_uchar)
        -> libc::c_uchar;
pub type set_actionfunc =
    unsafe extern "C" fn(actionvar: *mut libc::c_int,
                         actionmask: libc::c_int);
pub type is_actionfunc =
    extern "C" fn(actionvar: libc::c_int,
                  testmask: libc::c_int) -> libc::c_uchar;
pub type clear_actionfunc =
    unsafe extern "C" fn(actionvar: *mut libc::c_int,
                         actionmask: libc::c_int);
pub type BFPchar = extern "C" fn() -> *mut libc::c_char;
pub type BFP_lp = unsafe extern "C" fn(lp: *mut lprec);
pub type BFP_lpint =
    unsafe extern "C" fn(lp: *mut lprec, newsize: libc::c_int);
pub type BFPint_lp =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_int;
pub type BFPint_lpint =
    unsafe extern "C" fn(lp: *mut lprec, kind: libc::c_int)
        -> libc::c_int;
pub type BFPreal_lp =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_double;
pub type BFPrealp_lp =
    unsafe extern "C" fn(lp: *mut lprec) -> *mut libc::c_double;
pub type BFP_lpbool =
    unsafe extern "C" fn(lp: *mut lprec, maximum: libc::c_uchar);
pub type BFPint_lpbool =
    unsafe extern "C" fn(lp: *mut lprec, maximum: libc::c_uchar)
        -> libc::c_int;
pub type BFPint_lpintintboolbool =
    unsafe extern "C" fn(lp: *mut lprec, uservars: libc::c_int,
                         Bsize: libc::c_int,
                         usedpos: *mut libc::c_uchar,
                         _final: libc::c_uchar)
        -> libc::c_int;
pub type BFP_lprealint =
    unsafe extern "C" fn(lp: *mut lprec, pcol: *mut libc::c_double,
                         nzidx: *mut libc::c_int);
pub type BFP_lprealintrealint =
    unsafe extern "C" fn(lp: *mut lprec, prow: *mut libc::c_double,
                         pnzidx: *mut libc::c_int,
                         drow: *mut libc::c_double,
                         dnzidx: *mut libc::c_int);
pub type BFPbool_lp =
    unsafe extern "C" fn(lp: *mut lprec) -> libc::c_uchar;
pub type BFPbool_lpbool =
    unsafe extern "C" fn(lp: *mut lprec, changesign: libc::c_uchar)
        -> libc::c_uchar;
pub type BFPbool_lpint =
    unsafe extern "C" fn(lp: *mut lprec, size: libc::c_int)
        -> libc::c_uchar;
pub type BFPbool_lpintintchar =
    unsafe extern "C" fn(lp: *mut lprec, size: libc::c_int,
                         deltasize: libc::c_int,
                         options: *mut libc::c_char)
        -> libc::c_uchar;
pub type BFPbool_lpintintint =
    unsafe extern "C" fn(lp: *mut lprec, size: libc::c_int,
                         deltasize: libc::c_int,
                         sizeofvar: libc::c_int)
        -> libc::c_uchar;
pub type BFPlreal_lpintintreal =
    unsafe extern "C" fn(lp: *mut lprec, row_nr: libc::c_int,
                         col_nr: libc::c_int,
                         pcol: *mut libc::c_double)
        -> libc::c_double;
pub type BFPreal_lplrealreal =
    unsafe extern "C" fn(lp: *mut lprec, theta: libc::c_double,
                         pcol: *mut libc::c_double)
        -> libc::c_double;
pub type getcolumnex_func =
    unsafe extern "C" fn(lp: *mut lprec, colnr: libc::c_int,
                         nzvalues: *mut libc::c_double,
                         nzrows: *mut libc::c_int,
                         mapin: *mut libc::c_int)
        -> libc::c_int;
pub type BFPint_lpintrealcbintint =
    unsafe extern "C" fn(lp: *mut lprec, items: libc::c_int,
                         cb: getcolumnex_func,
                         maprow: *mut libc::c_int,
                         mapcol: *mut libc::c_int)
        -> libc::c_int;
pub type XLIchar = extern "C" fn() -> *mut libc::c_char;
pub type XLIbool_lpintintint =
    unsafe extern "C" fn(lp: *mut lprec, size: libc::c_int,
                         deltasize: libc::c_int,
                         sizevar: libc::c_int)
        -> libc::c_uchar;
pub type XLIbool_lpcharcharcharint =
    unsafe extern "C" fn(lp: *mut lprec,
                         modelname: *mut libc::c_char,
                         dataname: *mut libc::c_char,
                         options: *mut libc::c_char,
                         verbose: libc::c_int)
        -> libc::c_uchar;
pub type XLIbool_lpcharcharbool =
    unsafe extern "C" fn(lp: *mut lprec,
                         filename: *mut libc::c_char,
                         options: *mut libc::c_char,
                         results: libc::c_uchar)
        -> libc::c_uchar;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__lprec {
    pub add_column: *mut add_column_func,
    pub add_columnex: *mut add_columnex_func,
    pub add_constraint: *mut add_constraint_func,
    pub add_constraintex: *mut add_constraintex_func,
    pub add_lag_con: *mut add_lag_con_func,
    pub add_SOS: *mut add_SOS_func,
    pub column_in_lp: *mut column_in_lp_func,
    pub copy_lp: *mut copy_lp_func,
    pub default_basis: *mut default_basis_func,
    pub del_column: *mut del_column_func,
    pub del_constraint: *mut del_constraint_func,
    pub delete_lp: *mut delete_lp_func,
    pub dualize_lp: *mut dualize_lp_func,
    pub free_lp: *mut free_lp_func,
    pub get_anti_degen: *mut get_anti_degen_func,
    pub get_basis: *mut get_basis_func,
    pub get_basiscrash: *mut get_basiscrash_func,
    pub get_bb_depthlimit: *mut get_bb_depthlimit_func,
    pub get_bb_floorfirst: *mut get_bb_floorfirst_func,
    pub get_bb_rule: *mut get_bb_rule_func,
    pub get_bounds_tighter: *mut get_bounds_tighter_func,
    pub get_break_at_value: *mut get_break_at_value_func,
    pub get_col_name: *mut get_col_name_func,
    pub get_columnex: *mut get_columnex_func,
    pub get_constr_type: *mut get_constr_type_func,
    pub get_constr_value: *mut get_constr_value_func,
    pub get_constraints: *mut get_constraints_func,
    pub get_dual_solution: *mut get_dual_solution_func,
    pub get_epsb: *mut get_epsb_func,
    pub get_epsd: *mut get_epsd_func,
    pub get_epsel: *mut get_epsel_func,
    pub get_epsint: *mut get_epsint_func,
    pub get_epsperturb: *mut get_epsperturb_func,
    pub get_epspivot: *mut get_epspivot_func,
    pub get_improve: *mut get_improve_func,
    pub get_infinite: *mut get_infinite_func,
    pub get_lambda: *mut get_lambda_func,
    pub get_lowbo: *mut get_lowbo_func,
    pub get_lp_index: *mut get_lp_index_func,
    pub get_lp_name: *mut get_lp_name_func,
    pub get_Lrows: *mut get_Lrows_func,
    pub get_mat: *mut get_mat_func,
    pub get_mat_byindex: *mut get_mat_byindex_func,
    pub get_max_level: *mut get_max_level_func,
    pub get_maxpivot: *mut get_maxpivot_func,
    pub get_mip_gap: *mut get_mip_gap_func,
    pub get_multiprice: *mut get_multiprice_func,
    pub get_nameindex: *mut get_nameindex_func,
    pub get_Ncolumns: *mut get_Ncolumns_func,
    pub get_negrange: *mut get_negrange_func,
    pub get_nonzeros: *mut get_nz_func,
    pub get_Norig_columns: *mut get_Norig_columns_func,
    pub get_Norig_rows: *mut get_Norig_rows_func,
    pub get_Nrows: *mut get_Nrows_func,
    pub get_obj_bound: *mut get_obj_bound_func,
    pub get_objective: *mut get_objective_func,
    pub get_orig_index: *mut get_orig_index_func,
    pub get_origcol_name: *mut get_origcol_name_func,
    pub get_origrow_name: *mut get_origrow_name_func,
    pub get_partialprice: *mut get_partialprice_func,
    pub get_pivoting: *mut get_pivoting_func,
    pub get_presolve: *mut get_presolve_func,
    pub get_presolveloops: *mut get_presolveloops_func,
    pub get_primal_solution: *mut get_primal_solution_func,
    pub get_print_sol: *mut get_print_sol_func,
    pub get_pseudocosts: *mut get_pseudocosts_func,
    pub get_ptr_constraints: *mut get_ptr_constraints_func,
    pub get_ptr_dual_solution: *mut get_ptr_dual_solution_func,
    pub get_ptr_lambda: *mut get_ptr_lambda_func,
    pub get_ptr_primal_solution: *mut get_ptr_primal_solution_func,
    pub get_ptr_sensitivity_obj: *mut get_ptr_sensitivity_obj_func,
    pub get_ptr_sensitivity_objex: *mut get_ptr_sensitivity_objex_func,
    pub get_ptr_sensitivity_rhs: *mut get_ptr_sensitivity_rhs_func,
    pub get_ptr_variables: *mut get_ptr_variables_func,
    pub get_rh: *mut get_rh_func,
    pub get_rh_range: *mut get_rh_range_func,
    pub get_row: *mut get_row_func,
    pub get_rowex: *mut get_rowex_func,
    pub get_row_name: *mut get_row_name_func,
    pub get_scalelimit: *mut get_scalelimit_func,
    pub get_scaling: *mut get_scaling_func,
    pub get_sensitivity_obj: *mut get_sensitivity_obj_func,
    pub get_sensitivity_objex: *mut get_sensitivity_objex_func,
    pub get_sensitivity_rhs: *mut get_sensitivity_rhs_func,
    pub get_simplextype: *mut get_simplextype_func,
    pub get_solutioncount: *mut get_solutioncount_func,
    pub get_solutionlimit: *mut get_solutionlimit_func,
    pub get_status: *mut get_status_func,
    pub get_statustext: *mut get_statustext_func,
    pub get_timeout: *mut get_timeout_func,
    pub get_total_iter: *mut get_total_iter_func,
    pub get_total_nodes: *mut get_total_nodes_func,
    pub get_upbo: *mut get_upbo_func,
    pub get_var_branch: *mut get_var_branch_func,
    pub get_var_dualresult: *mut get_var_dualresult_func,
    pub get_var_primalresult: *mut get_var_primalresult_func,
    pub get_var_priority: *mut get_var_priority_func,
    pub get_variables: *mut get_variables_func,
    pub get_verbose: *mut get_verbose_func,
    pub get_working_objective: *mut get_working_objective_func,
    pub has_BFP: *mut has_BFP_func,
    pub has_XLI: *mut has_XLI_func,
    pub is_add_rowmode: *mut is_add_rowmode_func,
    pub is_anti_degen: *mut is_anti_degen_func,
    pub is_binary: *mut is_binary_func,
    pub is_break_at_first: *mut is_break_at_first_func,
    pub is_constr_type: *mut is_constr_type_func,
    pub is_debug: *mut is_debug_func,
    pub is_feasible: *mut is_feasible_func,
    pub is_infinite: *mut is_infinite_func,
    pub is_int: *mut is_int_func,
    pub is_integerscaling: *mut is_integerscaling_func,
    pub is_lag_trace: *mut is_lag_trace_func,
    pub is_maxim: *mut is_maxim_func,
    pub is_nativeBFP: *mut is_nativeBFP_func,
    pub is_nativeXLI: *mut is_nativeXLI_func,
    pub is_negative: *mut is_negative_func,
    pub is_obj_in_basis: *mut is_obj_in_basis_func,
    pub is_piv_mode: *mut is_piv_mode_func,
    pub is_piv_rule: *mut is_piv_rule_func,
    pub is_presolve: *mut is_presolve_func,
    pub is_scalemode: *mut is_scalemode_func,
    pub is_scaletype: *mut is_scaletype_func,
    pub is_semicont: *mut is_semicont_func,
    pub is_SOS_var: *mut is_SOS_var_func,
    pub is_trace: *mut is_trace_func,
    pub is_unbounded: *mut is_unbounded_func,
    pub is_use_names: *mut is_use_names_func,
    pub lp_solve_version: *mut lp_solve_version_func,
    pub make_lp: *mut make_lp_func,
    pub print_constraints: *mut print_constraints_func,
    pub print_debugdump: *mut print_debugdump_func,
    pub print_duals: *mut print_duals_func,
    pub print_lp: *mut print_lp_func,
    pub print_objective: *mut print_objective_func,
    pub print_scales: *mut print_scales_func,
    pub print_solution: *mut print_solution_func,
    pub print_str: *mut print_str_func,
    pub print_tableau: *mut print_tableau_func,
    pub put_abortfunc: *mut put_abortfunc_func,
    pub put_bb_nodefunc: *mut put_bb_nodefunc_func,
    pub put_bb_branchfunc: *mut put_bb_branchfunc_func,
    pub put_logfunc: *mut put_logfunc_func,
    pub put_msgfunc: *mut put_msgfunc_func,
    pub read_LP: *mut read_LP_func,
    pub read_MPS: *mut read_MPS_func,
    pub read_XLI: *mut read_XLI_func,
    pub read_params: *mut read_params_func,
    pub read_basis: *mut read_basis_func,
    pub reset_basis: *mut reset_basis_func,
    pub reset_params: *mut reset_params_func,
    pub resize_lp: *mut resize_lp_func,
    pub set_add_rowmode: *mut set_add_rowmode_func,
    pub set_anti_degen: *mut set_anti_degen_func,
    pub set_basisvar: *mut set_basisvar_func,
    pub set_basis: *mut set_basis_func,
    pub set_basiscrash: *mut set_basiscrash_func,
    pub set_bb_depthlimit: *mut set_bb_depthlimit_func,
    pub set_bb_floorfirst: *mut set_bb_floorfirst_func,
    pub set_bb_rule: *mut set_bb_rule_func,
    pub set_BFP: *mut set_BFP_func,
    pub set_binary: *mut set_binary_func,
    pub set_bounds: *mut set_bounds_func,
    pub set_bounds_tighter: *mut set_bounds_tighter_func,
    pub set_break_at_first: *mut set_break_at_first_func,
    pub set_break_at_value: *mut set_break_at_value_func,
    pub set_column: *mut set_column_func,
    pub set_columnex: *mut set_columnex_func,
    pub set_col_name: *mut set_col_name_func,
    pub set_constr_type: *mut set_constr_type_func,
    pub set_debug: *mut set_debug_func,
    pub set_epsb: *mut set_epsb_func,
    pub set_epsd: *mut set_epsd_func,
    pub set_epsel: *mut set_epsel_func,
    pub set_epsint: *mut set_epsint_func,
    pub set_epslevel: *mut set_epslevel_func,
    pub set_epsperturb: *mut set_epsperturb_func,
    pub set_epspivot: *mut set_epspivot_func,
    pub set_unbounded: *mut set_unbounded_func,
    pub set_improve: *mut set_improve_func,
    pub set_infinite: *mut set_infinite_func,
    pub set_int: *mut set_int_func,
    pub set_lag_trace: *mut set_lag_trace_func,
    pub set_lowbo: *mut set_lowbo_func,
    pub set_lp_name: *mut set_lp_name_func,
    pub set_mat: *mut set_mat_func,
    pub set_maxim: *mut set_maxim_func,
    pub set_maxpivot: *mut set_maxpivot_func,
    pub set_minim: *mut set_minim_func,
    pub set_mip_gap: *mut set_mip_gap_func,
    pub set_multiprice: *mut set_multiprice_func,
    pub set_negrange: *mut set_negrange_func,
    pub set_obj_bound: *mut set_obj_bound_func,
    pub set_obj_fn: *mut set_obj_fn_func,
    pub set_obj_fnex: *mut set_obj_fnex_func,
    pub set_obj: *mut set_obj_func,
    pub set_obj_in_basis: *mut set_obj_in_basis_func,
    pub set_outputfile: *mut set_outputfile_func,
    pub set_outputstream: *mut set_outputstream_func,
    pub set_partialprice: *mut set_partialprice_func,
    pub set_pivoting: *mut set_pivoting_func,
    pub set_preferdual: *mut set_preferdual_func,
    pub set_presolve: *mut set_presolve_func,
    pub set_print_sol: *mut set_print_sol_func,
    pub set_pseudocosts: *mut set_pseudocosts_func,
    pub set_rh: *mut set_rh_func,
    pub set_rh_range: *mut set_rh_range_func,
    pub set_rh_vec: *mut set_rh_vec_func,
    pub set_row: *mut set_row_func,
    pub set_rowex: *mut set_rowex_func,
    pub set_row_name: *mut set_row_name_func,
    pub set_scalelimit: *mut set_scalelimit_func,
    pub set_scaling: *mut set_scaling_func,
    pub set_semicont: *mut set_semicont_func,
    pub set_sense: *mut set_sense_func,
    pub set_simplextype: *mut set_simplextype_func,
    pub set_solutionlimit: *mut set_solutionlimit_func,
    pub set_timeout: *mut set_timeout_func,
    pub set_trace: *mut set_trace_func,
    pub set_upbo: *mut set_upbo_func,
    pub set_use_names: *mut set_use_names_func,
    pub set_var_branch: *mut set_var_branch_func,
    pub set_var_weights: *mut set_var_weights_func,
    pub set_verbose: *mut set_verbose_func,
    pub set_XLI: *mut set_XLI_func,
    pub solve: *mut solve_func,
    pub str_add_column: *mut str_add_column_func,
    pub str_add_constraint: *mut str_add_constraint_func,
    pub str_add_lag_con: *mut str_add_lag_con_func,
    pub str_set_obj_fn: *mut str_set_obj_fn_func,
    pub str_set_rh_vec: *mut str_set_rh_vec_func,
    pub time_elapsed: *mut time_elapsed_func,
    pub unscale: *mut unscale_func,
    pub write_lp: *mut write_lp_func,
    pub write_LP: *mut write_LP_func,
    pub write_mps: *mut write_mps_func,
    pub write_MPS: *mut write_MPS_func,
    pub write_freemps: *mut write_freemps_func,
    pub write_freeMPS: *mut write_freeMPS_func,
    pub write_XLI: *mut write_XLI_func,
    pub write_basis: *mut write_basis_func,
    pub write_params: *mut write_params_func,
    pub alignmentspacer: *mut libc::c_int,
    pub lp_name: *mut libc::c_char,
    pub sum: libc::c_int,
    pub rows: libc::c_int,
    pub columns: libc::c_int,
    pub equalities: libc::c_int,
    pub boundedvars: libc::c_int,
    pub INTfuture1: libc::c_int,
    pub sum_alloc: libc::c_int,
    pub rows_alloc: libc::c_int,
    pub columns_alloc: libc::c_int,
    pub source_is_file: libc::c_uchar,
    pub model_is_pure: libc::c_uchar,
    pub model_is_valid: libc::c_uchar,
    pub tighten_on_set: libc::c_uchar,
    pub names_used: libc::c_uchar,
    pub use_row_names: libc::c_uchar,
    pub use_col_names: libc::c_uchar,
    pub lag_trace: libc::c_uchar,
    pub spx_trace: libc::c_uchar,
    pub bb_trace: libc::c_uchar,
    pub streamowned: libc::c_uchar,
    pub obj_in_basis: libc::c_uchar,
    pub spx_status: libc::c_int,
    pub lag_status: libc::c_int,
    pub solutioncount: libc::c_int,
    pub solutionlimit: libc::c_int,
    pub real_solution: libc::c_double,
    pub solution: *mut libc::c_double,
    pub best_solution: *mut libc::c_double,
    pub full_solution: *mut libc::c_double,
    pub edgeVector: *mut libc::c_double,
    pub drow: *mut libc::c_double,
    pub nzdrow: *mut libc::c_int,
    pub duals: *mut libc::c_double,
    pub full_duals: *mut libc::c_double,
    pub dualsfrom: *mut libc::c_double,
    pub dualstill: *mut libc::c_double,
    pub objfrom: *mut libc::c_double,
    pub objtill: *mut libc::c_double,
    pub objfromvalue: *mut libc::c_double,
    pub orig_obj: *mut libc::c_double,
    pub obj: *mut libc::c_double,
    pub current_iter: libc::c_longlong,
    pub total_iter: libc::c_longlong,
    pub current_bswap: libc::c_longlong,
    pub total_bswap: libc::c_longlong,
    pub solvecount: libc::c_int,
    pub max_pivots: libc::c_int,
    pub simplex_strategy: libc::c_int,
    pub simplex_mode: libc::c_int,
    pub verbose: libc::c_int,
    pub print_sol: libc::c_int,
    pub outstream: *mut libc::FILE,
    pub bb_varbranch: *mut libc::c_uchar,
    pub piv_strategy: libc::c_int,
    pub _piv_rule_: libc::c_int,
    pub bb_rule: libc::c_int,
    pub bb_floorfirst: libc::c_uchar,
    pub bb_breakfirst: libc::c_uchar,
    pub _piv_left_: libc::c_uchar,
    pub BOOLfuture1: libc::c_uchar,
    pub scalelimit: libc::c_double,
    pub scalemode: libc::c_int,
    pub improve: libc::c_int,
    pub anti_degen: libc::c_int,
    pub do_presolve: libc::c_int,
    pub presolveloops: libc::c_int,
    pub perturb_count: libc::c_int,
    pub row_name: *mut *mut hashelem,
    pub col_name: *mut *mut hashelem,
    pub rowname_hashtab: *mut hashtable,
    pub colname_hashtab: *mut hashtable,
    pub rowblocks: *mut partialrec,
    pub colblocks: *mut partialrec,
    pub var_type: *mut libc::c_uchar,
    pub multivars: *mut multirec,
    pub multiblockdiv: libc::c_int,
    pub fixedvars: libc::c_int,
    pub int_vars: libc::c_int,
    pub sc_vars: libc::c_int,
    pub sc_lobound: *mut libc::c_double,
    pub var_is_free: *mut libc::c_int,
    pub var_priority: *mut libc::c_int,
    pub GUB: *mut SOSgroup,
    pub sos_vars: libc::c_int,
    pub sos_ints: libc::c_int,
    pub SOS: *mut SOSgroup,
    pub sos_priority: *mut libc::c_int,
    pub bsolveVal: *mut libc::c_double,
    pub bsolveIdx: *mut libc::c_int,
    pub orig_rhs: *mut libc::c_double,
    pub rhs: *mut libc::c_double,
    pub row_type: *mut libc::c_int,
    pub longsteps: *mut multirec,
    pub orig_upbo: *mut libc::c_double,
    pub upbo: *mut libc::c_double,
    pub orig_lowbo: *mut libc::c_double,
    pub lowbo: *mut libc::c_double,
    pub matA: *mut MATrec,
    pub invB: *mut INVrec,
    pub bb_bounds: *mut BBrec,
    pub rootbounds: *mut BBrec,
    pub bb_basis: *mut basisrec,
    pub rootbasis: *mut basisrec,
    pub monitor: *mut OBJmonrec,
    pub scalars: *mut libc::c_double,
    pub scaling_used: libc::c_uchar,
    pub columns_scaled: libc::c_uchar,
    pub varmap_locked: libc::c_uchar,
    pub basis_valid: libc::c_uchar,
    pub crashmode: libc::c_int,
    pub var_basic: *mut libc::c_int,
    pub val_nonbasic: *mut libc::c_double,
    pub is_basic: *mut libc::c_uchar,
    pub is_lower: *mut libc::c_uchar,
    pub rejectpivot: *mut libc::c_int,
    pub bb_PseudoCost: *mut BBPSrec,
    pub bb_PseudoUpdates: libc::c_int,
    pub bb_strongbranches: libc::c_int,
    pub is_strongbranch: libc::c_int,
    pub bb_improvements: libc::c_int,
    pub rhsmax: libc::c_double,
    pub suminfeas: libc::c_double,
    pub bigM: libc::c_double,
    pub P1extraVal: libc::c_double,
    pub P1extraDim: libc::c_int,
    pub spx_action: libc::c_int,
    pub spx_perturbed: libc::c_uchar,
    pub bb_break: libc::c_uchar,
    pub wasPreprocessed: libc::c_uchar,
    pub wasPresolved: libc::c_uchar,
    pub INTfuture2: libc::c_int,
    pub matL: *mut MATrec,
    pub lag_rhs: *mut libc::c_double,
    pub lag_con_type: *mut libc::c_int,
    pub lambda: *mut libc::c_double,
    pub lag_bound: libc::c_double,
    pub lag_accept: libc::c_double,
    pub infinite: libc::c_double,
    pub negrange: libc::c_double,
    pub epsmachine: libc::c_double,
    pub epsvalue: libc::c_double,
    pub epsprimal: libc::c_double,
    pub epsdual: libc::c_double,
    pub epspivot: libc::c_double,
    pub epsperturb: libc::c_double,
    pub epssolution: libc::c_double,
    pub bb_status: libc::c_int,
    pub bb_level: libc::c_int,
    pub bb_maxlevel: libc::c_int,
    pub bb_limitlevel: libc::c_int,
    pub bb_totalnodes: libc::c_longlong,
    pub bb_solutionlevel: libc::c_int,
    pub bb_cutpoolsize: libc::c_int,
    pub bb_cutpoolused: libc::c_int,
    pub bb_constraintOF: libc::c_int,
    pub bb_cuttype: *mut libc::c_int,
    pub bb_varactive: *mut libc::c_int,
    pub bb_upperchange: *mut DeltaVrec,
    pub bb_lowerchange: *mut DeltaVrec,
    pub bb_deltaOF: libc::c_double,
    pub bb_breakOF: libc::c_double,
    pub bb_limitOF: libc::c_double,
    pub bb_heuristicOF: libc::c_double,
    pub bb_parentOF: libc::c_double,
    pub bb_workOF: libc::c_double,
    pub presolve_undo: *mut presolveundorec,
    pub workarrays: *mut workarraysrec,
    pub epsint: libc::c_double,
    pub mip_absgap: libc::c_double,
    pub mip_relgap: libc::c_double,
    pub timecreate: libc::c_double,
    pub timestart: libc::c_double,
    pub timeheuristic: libc::c_double,
    pub timepresolved: libc::c_double,
    pub timeend: libc::c_double,
    pub sectimeout: libc::c_long,
    pub ex_status: *mut libc::c_char,
    pub hBFP: *mut libc::c_void,
    pub bfp_name: *mut BFPchar,
    pub bfp_compatible: *mut BFPbool_lpintintint,
    pub bfp_init: *mut BFPbool_lpintintchar,
    pub bfp_free: *mut BFP_lp,
    pub bfp_resize: *mut BFPbool_lpint,
    pub bfp_memallocated: *mut BFPint_lp,
    pub bfp_restart: *mut BFPbool_lp,
    pub bfp_mustrefactorize: *mut BFPbool_lp,
    pub bfp_preparefactorization: *mut BFPint_lp,
    pub bfp_factorize: *mut BFPint_lpintintboolbool,
    pub bfp_finishfactorization: *mut BFP_lp,
    pub bfp_updaterefactstats: *mut BFP_lp,
    pub bfp_prepareupdate: *mut BFPlreal_lpintintreal,
    pub bfp_pivotRHS: *mut BFPreal_lplrealreal,
    pub bfp_finishupdate: *mut BFPbool_lpbool,
    pub bfp_ftran_prepare: *mut BFP_lprealint,
    pub bfp_ftran_normal: *mut BFP_lprealint,
    pub bfp_btran_normal: *mut BFP_lprealint,
    pub bfp_btran_double: *mut BFP_lprealintrealint,
    pub bfp_status: *mut BFPint_lp,
    pub bfp_nonzeros: *mut BFPint_lpbool,
    pub bfp_implicitslack: *mut BFPbool_lp,
    pub bfp_indexbase: *mut BFPint_lp,
    pub bfp_rowoffset: *mut BFPint_lp,
    pub bfp_pivotmax: *mut BFPint_lp,
    pub bfp_pivotalloc: *mut BFPbool_lpint,
    pub bfp_colcount: *mut BFPint_lp,
    pub bfp_canresetbasis: *mut BFPbool_lp,
    pub bfp_efficiency: *mut BFPreal_lp,
    pub bfp_pivotvector: *mut BFPrealp_lp,
    pub bfp_pivotcount: *mut BFPint_lp,
    pub bfp_refactcount: *mut BFPint_lpint,
    pub bfp_isSetI: *mut BFPbool_lp,
    pub bfp_findredundant: *mut BFPint_lpintrealcbintint,
    pub hXLI: *mut libc::c_void,
    pub xli_name: *mut XLIchar,
    pub xli_compatible: *mut XLIbool_lpintintint,
    pub xli_readmodel: *mut XLIbool_lpcharcharcharint,
    pub xli_writemodel: *mut XLIbool_lpcharcharbool,
    pub userabort: *mut userabortfunc,
    pub report: *mut reportfunc,
    pub explain: *mut explainfunc,
    pub get_lpcolumn: *mut getvectorfunc,
    pub get_basiscolumn: *mut getpackedfunc,
    pub get_OF_active: *mut get_OF_activefunc,
    pub getMDO: *mut getMDOfunc,
    pub invert: *mut invertfunc,
    pub set_action: *mut set_actionfunc,
    pub is_action: *mut is_actionfunc,
    pub clear_action: *mut clear_actionfunc,
    pub ctrlc: *mut lphandle_intfunc,
    pub ctrlchandle: *mut libc::c_void,
    pub writelog: *mut lphandlestr_func,
    pub loghandle: *mut libc::c_void,
    pub debuginfo: *mut lphandlestr_func,
    pub usermessage: *mut lphandleint_func,
    pub msgmask: libc::c_int,
    pub msghandle: *mut libc::c_void,
    pub bb_usenode: *mut lphandleint_intfunc,
    pub bb_nodehandle: *mut libc::c_void,
    pub bb_usebranch: *mut lphandleint_intfunc,
    pub bb_branchhandle: *mut libc::c_void,
    pub rowcol_name: *mut libc::c_char,
}
impl ::core::clone::Clone for Struct__lprec {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for Struct__lprec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[cfg(not(windows))]
pub type read_modeldata_func =
    unsafe extern "C" fn(userhandle: *mut libc::c_void,
                         buf: *mut libc::c_char,
                         max_size: libc::c_int)
        -> libc::c_int;
#[cfg(not(windows))]
pub type write_modeldata_func =
    unsafe extern "C" fn(userhandle: *mut libc::c_void,
                         buf: *mut libc::c_char)
        -> libc::c_int;

#[cfg(windows)]
pub type read_modeldata_func =
    unsafe extern "stdcall" fn(userhandle: *mut libc::c_void,
                         buf: *mut libc::c_char,
                         max_size: libc::c_int)
        -> libc::c_int;
#[cfg(windows)]
pub type write_modeldata_func =
    unsafe extern "stdcall" fn(userhandle: *mut libc::c_void,
                         buf: *mut libc::c_char)
        -> libc::c_int;

#[cfg(not(windows))]
#[link(name = "lpsolve55")]
extern "C" {
    pub fn allocCHAR(lp: *mut lprec, ptr: *mut *mut libc::c_char,
                     size: libc::c_int,
                     clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocMYBOOL(lp: *mut lprec, ptr: *mut *mut libc::c_uchar,
                       size: libc::c_int,
                       clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocINT(lp: *mut lprec, ptr: *mut *mut libc::c_int,
                    size: libc::c_int,
                    clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocREAL(lp: *mut lprec, ptr: *mut *mut libc::c_double,
                     size: libc::c_int,
                     clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocLREAL(lp: *mut lprec, ptr: *mut *mut libc::c_double,
                      size: libc::c_int,
                      clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocFREE(lp: *mut lprec, ptr: *mut *mut libc::c_void)
     -> libc::c_uchar;
    pub fn cloneREAL(lp: *mut lprec, origlist: *mut libc::c_double,
                     size: libc::c_int)
     -> *mut libc::c_double;
    pub fn cloneMYBOOL(lp: *mut lprec, origlist: *mut libc::c_uchar,
                       size: libc::c_int)
     -> *mut libc::c_uchar;
    pub fn cloneINT(lp: *mut lprec, origlist: *mut libc::c_int,
                    size: libc::c_int)
     -> *mut libc::c_int;
    pub fn comp_bits(bitarray1: *mut libc::c_uchar,
                     bitarray2: *mut libc::c_uchar,
                     items: libc::c_int) -> libc::c_int;
    pub fn mempool_create(lp: *mut lprec) -> *mut workarraysrec;
    pub fn mempool_obtainVector(mempool: *mut workarraysrec,
                                count: libc::c_int,
                                unitsize: libc::c_int)
     -> *mut libc::c_char;
    pub fn mempool_releaseVector(mempool: *mut workarraysrec,
                                 memvector: *mut libc::c_char,
                                 forcefree: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mempool_free(mempool: *mut *mut workarraysrec)
     -> libc::c_uchar;
    pub fn roundVector(myvector: *mut libc::c_double,
                       endpos: libc::c_int,
                       roundzero: libc::c_double);
    pub fn normalizeVector(myvector: *mut libc::c_double,
                           endpos: libc::c_int)
     -> libc::c_double;
    pub fn swapINT(item1: *mut libc::c_int,
                   item2: *mut libc::c_int);
    pub fn swapREAL(item1: *mut libc::c_double,
                    item2: *mut libc::c_double);
    pub fn swapPTR(item1: *mut *mut libc::c_void,
                   item2: *mut *mut libc::c_void);
    pub fn restoreINT(valREAL: libc::c_double,
                      epsilon: libc::c_double)
     -> libc::c_double;
    pub fn roundToPrecision(value: libc::c_double,
                            precision: libc::c_double)
     -> libc::c_double;
    pub fn searchFor(target: libc::c_int,
                     attributes: *mut libc::c_int,
                     size: libc::c_int,
                     offset: libc::c_int,
                     absolute: libc::c_uchar)
     -> libc::c_int;
    pub fn isINT(lp: *mut lprec, value: libc::c_double)
     -> libc::c_uchar;
    pub fn isOrigFixed(lp: *mut lprec, varno: libc::c_int)
     -> libc::c_uchar;
    pub fn chsign_bounds(lobound: *mut libc::c_double,
                         upbound: *mut libc::c_double);
    pub fn rand_uniform(lp: *mut lprec, range: libc::c_double)
     -> libc::c_double;
    pub fn createLink(size: libc::c_int, linkmap: *mut *mut LLrec,
                      usedpos: *mut libc::c_uchar)
     -> libc::c_int;
    pub fn freeLink(linkmap: *mut *mut LLrec) -> libc::c_uchar;
    pub fn sizeLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn isActiveLink(linkmap: *mut LLrec, itemnr: libc::c_int)
     -> libc::c_uchar;
    pub fn countActiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn countInactiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn firstActiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn lastActiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn appendLink(linkmap: *mut LLrec, newitem: libc::c_int)
     -> libc::c_uchar;
    pub fn insertLink(linkmap: *mut LLrec, afteritem: libc::c_int,
                      newitem: libc::c_int)
     -> libc::c_uchar;
    pub fn setLink(linkmap: *mut LLrec, newitem: libc::c_int)
     -> libc::c_uchar;
    pub fn fillLink(linkmap: *mut LLrec) -> libc::c_uchar;
    pub fn nextActiveLink(linkmap: *mut LLrec,
                          backitemnr: libc::c_int)
     -> libc::c_int;
    pub fn prevActiveLink(linkmap: *mut LLrec,
                          forwitemnr: libc::c_int)
     -> libc::c_int;
    pub fn firstInactiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn lastInactiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn nextInactiveLink(linkmap: *mut LLrec,
                            backitemnr: libc::c_int)
     -> libc::c_int;
    pub fn prevInactiveLink(linkmap: *mut LLrec,
                            forwitemnr: libc::c_int)
     -> libc::c_int;
    pub fn removeLink(linkmap: *mut LLrec, itemnr: libc::c_int)
     -> libc::c_int;
    pub fn cloneLink(sourcemap: *mut LLrec, newsize: libc::c_int,
                     freesource: libc::c_uchar) -> *mut LLrec;
    pub fn compareLink(linkmap1: *mut LLrec, linkmap2: *mut LLrec)
     -> libc::c_int;
    pub fn verifyLink(linkmap: *mut LLrec, itemnr: libc::c_int,
                      doappend: libc::c_uchar)
     -> libc::c_uchar;
    pub fn createPackedVector(size: libc::c_int,
                              values: *mut libc::c_double,
                              workvector: *mut libc::c_int)
     -> *mut PVrec;
    pub fn pushPackedVector(PV: *mut PVrec, parent: *mut PVrec);
    pub fn unpackPackedVector(PV: *mut PVrec,
                              target: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn getvaluePackedVector(PV: *mut PVrec, index: libc::c_int)
     -> libc::c_double;
    pub fn popPackedVector(PV: *mut PVrec) -> *mut PVrec;
    pub fn freePackedVector(PV: *mut *mut PVrec) -> libc::c_uchar;
    pub fn create_hash_table(size: libc::c_int,
                             base: libc::c_int) -> *mut hashtable;
    pub fn free_hash_table(ht: *mut hashtable);
    pub fn findhash(name: *const libc::c_char, ht: *mut hashtable)
     -> *mut hashelem;
    pub fn puthash(name: *const libc::c_char,
                   index: libc::c_int, list: *mut *mut hashelem,
                   ht: *mut hashtable) -> *mut hashelem;
    pub fn drophash(name: *const libc::c_char,
                    list: *mut *mut hashelem, ht: *mut hashtable);
    pub fn free_hash_item(hp: *mut *mut hashelem);
    pub fn copy_hash_table(ht: *mut hashtable, list: *mut *mut hashelem,
                           newsize: libc::c_int) -> *mut hashtable;
    pub fn find_var(lp: *mut lprec, name: *mut libc::c_char,
                    verbose: libc::c_uchar)
     -> libc::c_int;
    pub fn find_row(lp: *mut lprec, name: *mut libc::c_char,
                    Unconstrained_rows_found: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_create(lp: *mut lprec, rows: libc::c_int,
                      columns: libc::c_int,
                      epsvalue: libc::c_double) -> *mut MATrec;
    pub fn mat_memopt(mat: *mut MATrec, rowextra: libc::c_int,
                      colextra: libc::c_int,
                      nzextra: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_free(matrix: *mut *mut MATrec);
    pub fn inc_matrow_space(mat: *mut MATrec,
                            deltarows: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_mapreplace(mat: *mut MATrec, rowmap: *mut LLrec,
                          colmap: *mut LLrec, insmat: *mut MATrec)
     -> libc::c_int;
    pub fn mat_matinsert(mat: *mut MATrec, insmat: *mut MATrec)
     -> libc::c_int;
    pub fn mat_zerocompact(mat: *mut MATrec) -> libc::c_int;
    pub fn mat_rowcompact(mat: *mut MATrec, dozeros: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_colcompact(mat: *mut MATrec, prev_rows: libc::c_int,
                          prev_cols: libc::c_int)
     -> libc::c_int;
    pub fn inc_matcol_space(mat: *mut MATrec,
                            deltacols: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_mat_space(mat: *mut MATrec, mindelta: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_shiftrows(mat: *mut MATrec, bbase: *mut libc::c_int,
                         delta: libc::c_int, varmap: *mut LLrec)
     -> libc::c_int;
    pub fn mat_shiftcols(mat: *mut MATrec, bbase: *mut libc::c_int,
                         delta: libc::c_int, varmap: *mut LLrec)
     -> libc::c_int;
    pub fn mat_extractmat(mat: *mut MATrec, rowmap: *mut LLrec,
                          colmap: *mut LLrec,
                          negated: libc::c_uchar) -> *mut MATrec;
    pub fn mat_appendrow(mat: *mut MATrec, count: libc::c_int,
                         row: *mut libc::c_double,
                         colno: *mut libc::c_int,
                         mult: libc::c_double,
                         checkrowmode: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_appendcol(mat: *mut MATrec, count: libc::c_int,
                         column: *mut libc::c_double,
                         rowno: *mut libc::c_int,
                         mult: libc::c_double,
                         checkrowmode: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_get_data(lp: *mut lprec, matindex: libc::c_int,
                        isrow: libc::c_uchar,
                        rownr: *mut *mut libc::c_int,
                        colnr: *mut *mut libc::c_int,
                        value: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn mat_set_rowmap(mat: *mut MATrec,
                          row_mat_index: libc::c_int,
                          rownr: libc::c_int,
                          colnr: libc::c_int,
                          col_mat_index: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_indexrange(mat: *mut MATrec, index: libc::c_int,
                          isrow: libc::c_uchar,
                          startpos: *mut libc::c_int,
                          endpos: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn mat_validate(mat: *mut MATrec) -> libc::c_uchar;
    pub fn mat_equalRows(mat: *mut MATrec, baserow: libc::c_int,
                         comprow: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_findelm(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int)
     -> libc::c_int;
    pub fn mat_findins(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int,
                       insertpos: *mut libc::c_int,
                       validate: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_multcol(mat: *mut MATrec, col_nr: libc::c_int,
                       mult: libc::c_double,
                       DoObj: libc::c_uchar);
    pub fn mat_getitem(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int)
     -> libc::c_double;
    pub fn mat_setitem(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int,
                       value: libc::c_double)
     -> libc::c_uchar;
    pub fn mat_additem(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int,
                       delta: libc::c_double)
     -> libc::c_uchar;
    pub fn mat_setvalue(mat: *mut MATrec, Row: libc::c_int,
                        Column: libc::c_int,
                        Value: libc::c_double,
                        doscale: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_nonzeros(mat: *mut MATrec) -> libc::c_int;
    pub fn mat_collength(mat: *mut MATrec, colnr: libc::c_int)
     -> libc::c_int;
    pub fn mat_rowlength(mat: *mut MATrec, rownr: libc::c_int)
     -> libc::c_int;
    pub fn mat_multrow(mat: *mut MATrec, row_nr: libc::c_int,
                       mult: libc::c_double);
    pub fn mat_multadd(mat: *mut MATrec,
                       lhsvector: *mut libc::c_double,
                       varnr: libc::c_int,
                       mult: libc::c_double);
    pub fn mat_setrow(mat: *mut MATrec, rowno: libc::c_int,
                      count: libc::c_int,
                      row: *mut libc::c_double,
                      colno: *mut libc::c_int,
                      doscale: libc::c_uchar,
                      checkrowmode: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_setcol(mat: *mut MATrec, colno: libc::c_int,
                      count: libc::c_int,
                      column: *mut libc::c_double,
                      rowno: *mut libc::c_int,
                      doscale: libc::c_uchar,
                      checkrowmode: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_mergemat(target: *mut MATrec, source: *mut MATrec,
                        usecolmap: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_checkcounts(mat: *mut MATrec,
                           rownum: *mut libc::c_int,
                           colnum: *mut libc::c_int,
                           freeonexit: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_expandcolumn(mat: *mut MATrec, colnr: libc::c_int,
                            column: *mut libc::c_double,
                            nzlist: *mut libc::c_int,
                            signedA: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_computemax(mat: *mut MATrec) -> libc::c_uchar;
    pub fn mat_transpose(mat: *mut MATrec) -> libc::c_uchar;
    pub fn invert(lp: *mut lprec, shiftbounds: libc::c_uchar,
                  _final: libc::c_uchar) -> libc::c_uchar;
    pub fn vec_compress(densevector: *mut libc::c_double,
                        startpos: libc::c_int,
                        endpos: libc::c_int,
                        epsilon: libc::c_double,
                        nzvector: *mut libc::c_double,
                        nzindex: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn vec_expand(nzvector: *mut libc::c_double,
                      nzindex: *mut libc::c_int,
                      densevector: *mut libc::c_double,
                      startpos: libc::c_int,
                      endpos: libc::c_int)
     -> libc::c_uchar;
    pub fn get_colIndexA(lp: *mut lprec, varset: libc::c_int,
                         colindex: *mut libc::c_int,
                         append: libc::c_uchar)
     -> libc::c_uchar;
    pub fn prod_Ax(lp: *mut lprec, coltarget: *mut libc::c_int,
                   input: *mut libc::c_double,
                   nzinput: *mut libc::c_int,
                   roundzero: libc::c_double,
                   ofscalar: libc::c_double,
                   output: *mut libc::c_double,
                   nzoutput: *mut libc::c_int,
                   roundmode: libc::c_int) -> libc::c_int;
    pub fn prod_xA(lp: *mut lprec, coltarget: *mut libc::c_int,
                   input: *mut libc::c_double,
                   nzinput: *mut libc::c_int,
                   roundzero: libc::c_double,
                   ofscalar: libc::c_double,
                   output: *mut libc::c_double,
                   nzoutput: *mut libc::c_int,
                   roundmode: libc::c_int) -> libc::c_int;
    pub fn prod_xA2(lp: *mut lprec, coltarget: *mut libc::c_int,
                    prow: *mut libc::c_double,
                    proundzero: libc::c_double,
                    pnzprow: *mut libc::c_int,
                    drow: *mut libc::c_double,
                    droundzero: libc::c_double,
                    dnzdrow: *mut libc::c_int,
                    ofscalar: libc::c_double,
                    roundmode: libc::c_int)
     -> libc::c_uchar;
    pub fn fimprove(lp: *mut lprec, pcol: *mut libc::c_double,
                    nzidx: *mut libc::c_int,
                    roundzero: libc::c_double)
     -> libc::c_uchar;
    pub fn ftran(lp: *mut lprec, rhsvector: *mut libc::c_double,
                 nzidx: *mut libc::c_int,
                 roundzero: libc::c_double);
    pub fn bimprove(lp: *mut lprec, rhsvector: *mut libc::c_double,
                    nzidx: *mut libc::c_int,
                    roundzero: libc::c_double)
     -> libc::c_uchar;
    pub fn btran(lp: *mut lprec, rhsvector: *mut libc::c_double,
                 nzidx: *mut libc::c_int,
                 roundzero: libc::c_double);
    pub fn fsolve(lp: *mut lprec, varin: libc::c_int,
                  pcol: *mut libc::c_double,
                  nzidx: *mut libc::c_int,
                  roundzero: libc::c_double,
                  ofscalar: libc::c_double,
                  prepareupdate: libc::c_uchar)
     -> libc::c_uchar;
    pub fn bsolve(lp: *mut lprec, row_nr: libc::c_int,
                  rhsvector: *mut libc::c_double,
                  nzidx: *mut libc::c_int,
                  roundzero: libc::c_double,
                  ofscalar: libc::c_double)
     -> libc::c_uchar;
    pub fn bsolve_xA2(lp: *mut lprec, coltarget: *mut libc::c_int,
                      row_nr1: libc::c_int,
                      vector1: *mut libc::c_double,
                      roundzero1: libc::c_double,
                      nzvector1: *mut libc::c_int,
                      row_nr2: libc::c_int,
                      vector2: *mut libc::c_double,
                      roundzero2: libc::c_double,
                      nzvector2: *mut libc::c_int,
                      roundmode: libc::c_int);
    pub fn createUndoLadder(lp: *mut lprec, levelitems: libc::c_int,
                            maxlevels: libc::c_int)
     -> *mut DeltaVrec;
    pub fn incrementUndoLadder(DV: *mut DeltaVrec) -> libc::c_int;
    pub fn modifyUndoLadder(DV: *mut DeltaVrec, itemno: libc::c_int,
                            target: *mut libc::c_double,
                            newvalue: libc::c_double)
     -> libc::c_uchar;
    pub fn countsUndoLadder(DV: *mut DeltaVrec) -> libc::c_int;
    pub fn restoreUndoLadder(DV: *mut DeltaVrec,
                             target: *mut libc::c_double)
     -> libc::c_int;
    pub fn decrementUndoLadder(DV: *mut DeltaVrec) -> libc::c_int;
    pub fn freeUndoLadder(DV: *mut *mut DeltaVrec) -> libc::c_uchar;
    pub fn appendUndoPresolve(lp: *mut lprec,
                              isprimal: libc::c_uchar,
                              beta: libc::c_double,
                              colnrDep: libc::c_int)
     -> libc::c_uchar;
    pub fn addUndoPresolve(lp: *mut lprec, isprimal: libc::c_uchar,
                           colnrElim: libc::c_int,
                           alpha: libc::c_double,
                           beta: libc::c_double,
                           colnrDep: libc::c_int)
     -> libc::c_uchar;
    pub fn create_BB(lp: *mut lprec, parentBB: *mut BBrec,
                     dofullcopy: libc::c_uchar) -> *mut BBrec;
    pub fn push_BB(lp: *mut lprec, parentBB: *mut BBrec,
                   varno: libc::c_int,
                   vartype: libc::c_int,
                   varcus: libc::c_int) -> *mut BBrec;
    pub fn initbranches_BB(BB: *mut BBrec) -> libc::c_uchar;
    pub fn fillbranches_BB(BB: *mut BBrec) -> libc::c_uchar;
    pub fn nextbranch_BB(BB: *mut BBrec) -> libc::c_uchar;
    pub fn strongbranch_BB(lp: *mut lprec, BB: *mut BBrec,
                           varno: libc::c_int,
                           vartype: libc::c_int,
                           varcus: libc::c_int)
     -> libc::c_uchar;
    pub fn initcuts_BB(lp: *mut lprec) -> libc::c_uchar;
    pub fn updatecuts_BB(lp: *mut lprec) -> libc::c_int;
    pub fn freecuts_BB(lp: *mut lprec) -> libc::c_uchar;
    pub fn findself_BB(BB: *mut BBrec) -> *mut BBrec;
    pub fn solve_LP(lp: *mut lprec, BB: *mut BBrec) -> libc::c_int;
    pub fn rcfbound_BB(BB: *mut BBrec, varno: libc::c_int,
                       isINT: libc::c_uchar,
                       newbound: *mut libc::c_double,
                       isfeasible: *mut libc::c_uchar)
     -> libc::c_int;
    pub fn findnode_BB(BB: *mut BBrec, varno: *mut libc::c_int,
                       vartype: *mut libc::c_int,
                       varcus: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn solve_BB(BB: *mut BBrec) -> libc::c_int;
    pub fn free_BB(BB: *mut *mut BBrec) -> libc::c_uchar;
    pub fn pop_BB(BB: *mut BBrec) -> *mut BBrec;
    pub fn run_BB(lp: *mut lprec) -> libc::c_int;
    pub fn create_SOSgroup(lp: *mut lprec) -> *mut SOSgroup;
    pub fn resize_SOSgroup(group: *mut SOSgroup);
    pub fn append_SOSgroup(group: *mut SOSgroup, SOS: *mut SOSrec)
     -> libc::c_int;
    pub fn clean_SOSgroup(group: *mut SOSgroup,
                          forceupdatemap: libc::c_uchar)
     -> libc::c_int;
    pub fn free_SOSgroup(group: *mut *mut SOSgroup);
    pub fn create_SOSrec(group: *mut SOSgroup,
                         name: *mut libc::c_char,
                         _type: libc::c_int,
                         priority: libc::c_int,
                         size: libc::c_int,
                         variables: *mut libc::c_int,
                         weights: *mut libc::c_double)
     -> *mut SOSrec;
    pub fn delete_SOSrec(group: *mut SOSgroup,
                         sosindex: libc::c_int)
     -> libc::c_uchar;
    pub fn append_SOSrec(SOS: *mut SOSrec, size: libc::c_int,
                         variables: *mut libc::c_int,
                         weights: *mut libc::c_double)
     -> libc::c_int;
    pub fn free_SOSrec(SOS: *mut SOSrec);
    pub fn make_SOSchain(lp: *mut lprec, forceresort: libc::c_uchar)
     -> libc::c_int;
    pub fn SOS_member_updatemap(group: *mut SOSgroup)
     -> libc::c_int;
    pub fn SOS_member_sortlist(group: *mut SOSgroup,
                               sosindex: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_shift_col(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int,
                         delta: libc::c_int, usedmap: *mut LLrec,
                         forceresort: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_member_delete(group: *mut SOSgroup,
                             sosindex: libc::c_int,
                             member: libc::c_int)
     -> libc::c_int;
    pub fn SOS_get_type(group: *mut SOSgroup, sosindex: libc::c_int)
     -> libc::c_int;
    pub fn SOS_infeasible(group: *mut SOSgroup,
                          sosindex: libc::c_int)
     -> libc::c_int;
    pub fn SOS_member_index(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            member: libc::c_int)
     -> libc::c_int;
    pub fn SOS_member_count(group: *mut SOSgroup,
                            sosindex: libc::c_int)
     -> libc::c_int;
    pub fn SOS_memberships(group: *mut SOSgroup,
                           column: libc::c_int)
     -> libc::c_int;
    pub fn SOS_get_candidates(group: *mut SOSgroup,
                              sosindex: libc::c_int,
                              column: libc::c_int,
                              excludetarget: libc::c_uchar,
                              upbound: *mut libc::c_double,
                              lobound: *mut libc::c_double)
     -> *mut libc::c_int;
    pub fn SOS_is_member(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int)
     -> libc::c_int;
    pub fn SOS_is_member_of_type(group: *mut SOSgroup,
                                 column: libc::c_int,
                                 sostype: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_set_GUB(group: *mut SOSgroup, sosindex: libc::c_int,
                       state: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_is_GUB(group: *mut SOSgroup, sosindex: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_is_marked(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_is_active(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_is_full(group: *mut SOSgroup, sosindex: libc::c_int,
                       column: libc::c_int,
                       activeonly: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_can_activate(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_set_marked(group: *mut SOSgroup,
                          sosindex: libc::c_int,
                          column: libc::c_int,
                          asactive: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_unmark(group: *mut SOSgroup, sosindex: libc::c_int,
                      column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_fix_unmarked(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            variable: libc::c_int,
                            bound: *mut libc::c_double,
                            value: libc::c_double,
                            isupper: libc::c_uchar,
                            diffcount: *mut libc::c_int,
                            changelog: *mut DeltaVrec)
     -> libc::c_int;
    pub fn SOS_fix_list(group: *mut SOSgroup, sosindex: libc::c_int,
                        variable: libc::c_int,
                        bound: *mut libc::c_double,
                        varlist: *mut libc::c_int,
                        isleft: libc::c_uchar,
                        changelog: *mut DeltaVrec) -> libc::c_int;
    pub fn SOS_is_satisfied(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            solution: *mut libc::c_double)
     -> libc::c_int;
    pub fn SOS_is_feasible(group: *mut SOSgroup,
                           sosindex: libc::c_int,
                           solution: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn lp_solve_version(majorversion: *mut libc::c_int,
                            minorversion: *mut libc::c_int,
                            release: *mut libc::c_int,
                            build: *mut libc::c_int);
    pub fn make_lp(rows: libc::c_int,
                   columns: libc::c_int) -> *mut lprec;
    pub fn resize_lp(lp: *mut lprec, rows: libc::c_int,
                     columns: libc::c_int)
     -> libc::c_uchar;
    pub fn get_status(lp: *mut lprec) -> libc::c_int;
    pub fn get_statustext(lp: *mut lprec, statuscode: libc::c_int)
     -> *mut libc::c_char;
    pub fn is_obj_in_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_obj_in_basis(lp: *mut lprec,
                            obj_in_basis: libc::c_uchar);
    pub fn copy_lp(lp: *mut lprec) -> *mut lprec;
    pub fn dualize_lp(lp: *mut lprec) -> libc::c_uchar;
    pub fn memopt_lp(lp: *mut lprec, rowextra: libc::c_int,
                     colextra: libc::c_int,
                     nzextra: libc::c_int)
     -> libc::c_uchar;
    pub fn delete_lp(lp: *mut lprec);
    pub fn free_lp(plp: *mut *mut lprec);
    pub fn set_lp_name(lp: *mut lprec, lpname: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn get_lp_name(lp: *mut lprec) -> *mut libc::c_char;
    pub fn has_BFP(lp: *mut lprec) -> libc::c_uchar;
    pub fn is_nativeBFP(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_BFP(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_XLI(xliname: *mut libc::c_char,
                    modelname: *mut libc::c_char,
                    dataname: *mut libc::c_char,
                    options: *mut libc::c_char,
                    verbose: libc::c_int) -> *mut lprec;
    pub fn write_XLI(lp: *mut lprec, filename: *mut libc::c_char,
                     options: *mut libc::c_char,
                     results: libc::c_uchar)
     -> libc::c_uchar;
    pub fn has_XLI(lp: *mut lprec) -> libc::c_uchar;
    pub fn is_nativeXLI(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_XLI(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_obj(lp: *mut lprec, colnr: libc::c_int,
                   value: libc::c_double)
     -> libc::c_uchar;
    pub fn set_obj_fn(lp: *mut lprec, row: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_obj_fnex(lp: *mut lprec, count: libc::c_int,
                        row: *mut libc::c_double,
                        colno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn str_set_obj_fn(lp: *mut lprec,
                          row_string: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_sense(lp: *mut lprec, maximize: libc::c_uchar);
    pub fn set_maxim(lp: *mut lprec);
    pub fn set_minim(lp: *mut lprec);
    pub fn is_maxim(lp: *mut lprec) -> libc::c_uchar;
    pub fn add_constraint(lp: *mut lprec, row: *mut libc::c_double,
                          constr_type: libc::c_int,
                          rh: libc::c_double)
     -> libc::c_uchar;
    pub fn add_constraintex(lp: *mut lprec, count: libc::c_int,
                            row: *mut libc::c_double,
                            colno: *mut libc::c_int,
                            constr_type: libc::c_int,
                            rh: libc::c_double)
     -> libc::c_uchar;
    pub fn set_add_rowmode(lp: *mut lprec, turnon: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_add_rowmode(lp: *mut lprec) -> libc::c_uchar;
    pub fn str_add_constraint(lp: *mut lprec,
                              row_string: *mut libc::c_char,
                              constr_type: libc::c_int,
                              rh: libc::c_double)
     -> libc::c_uchar;
    pub fn set_row(lp: *mut lprec, rownr: libc::c_int,
                   row: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_rowex(lp: *mut lprec, rownr: libc::c_int,
                     count: libc::c_int,
                     row: *mut libc::c_double,
                     colno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn get_row(lp: *mut lprec, rownr: libc::c_int,
                   row: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_rowex(lp: *mut lprec, rownr: libc::c_int,
                     row: *mut libc::c_double,
                     colno: *mut libc::c_int)
     -> libc::c_int;
    pub fn del_constraint(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_uchar;
    pub fn del_constraintex(lp: *mut lprec, rowmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn add_lag_con(lp: *mut lprec, row: *mut libc::c_double,
                       con_type: libc::c_int,
                       rhs: libc::c_double)
     -> libc::c_uchar;
    pub fn str_add_lag_con(lp: *mut lprec,
                           row_string: *mut libc::c_char,
                           con_type: libc::c_int,
                           rhs: libc::c_double)
     -> libc::c_uchar;
    pub fn set_lag_trace(lp: *mut lprec, lag_trace: libc::c_uchar);
    pub fn is_lag_trace(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_constr_type(lp: *mut lprec, rownr: libc::c_int,
                           con_type: libc::c_int)
     -> libc::c_uchar;
    pub fn get_constr_type(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_int;
    pub fn get_constr_value(lp: *mut lprec, rownr: libc::c_int,
                            count: libc::c_int,
                            primsolution: *mut libc::c_double,
                            nzindex: *mut libc::c_int)
     -> libc::c_double;
    pub fn is_constr_type(lp: *mut lprec, rownr: libc::c_int,
                          mask: libc::c_int)
     -> libc::c_uchar;
    pub fn get_str_constr_type(lp: *mut lprec,
                               con_type: libc::c_int)
     -> *mut libc::c_char;
    pub fn get_constr_class(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_int;
    pub fn get_str_constr_class(lp: *mut lprec,
                                con_class: libc::c_int)
     -> *mut libc::c_char;
    pub fn set_rh(lp: *mut lprec, rownr: libc::c_int,
                  value: libc::c_double) -> libc::c_uchar;
    pub fn get_rh(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn set_rh_range(lp: *mut lprec, rownr: libc::c_int,
                        deltavalue: libc::c_double)
     -> libc::c_uchar;
    pub fn get_rh_range(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn set_rh_vec(lp: *mut lprec, rh: *mut libc::c_double);
    pub fn str_set_rh_vec(lp: *mut lprec,
                          rh_string: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn add_column(lp: *mut lprec, column: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn add_columnex(lp: *mut lprec, count: libc::c_int,
                        column: *mut libc::c_double,
                        rowno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn str_add_column(lp: *mut lprec,
                          col_string: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_column(lp: *mut lprec, colnr: libc::c_int,
                      column: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_columnex(lp: *mut lprec, colnr: libc::c_int,
                        count: libc::c_int,
                        column: *mut libc::c_double,
                        rowno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn column_in_lp(lp: *mut lprec, column: *mut libc::c_double)
     -> libc::c_int;
    pub fn get_columnex(lp: *mut lprec, colnr: libc::c_int,
                        column: *mut libc::c_double,
                        nzrow: *mut libc::c_int)
     -> libc::c_int;
    pub fn get_column(lp: *mut lprec, colnr: libc::c_int,
                      column: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn del_column(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn del_columnex(lp: *mut lprec, colmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn set_mat(lp: *mut lprec, rownr: libc::c_int,
                   colnr: libc::c_int,
                   value: libc::c_double)
     -> libc::c_uchar;
    pub fn get_mat(lp: *mut lprec, rownr: libc::c_int,
                   colnr: libc::c_int) -> libc::c_double;
    pub fn get_mat_byindex(lp: *mut lprec, matindex: libc::c_int,
                           isrow: libc::c_uchar,
                           adjustsign: libc::c_uchar)
     -> libc::c_double;
    pub fn get_nonzeros(lp: *mut lprec) -> libc::c_int;
    pub fn set_bounds_tighter(lp: *mut lprec,
                              tighten: libc::c_uchar);
    pub fn get_bounds(lp: *mut lprec, column: libc::c_int,
                      lower: *mut libc::c_double,
                      upper: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_bounds_tighter(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_upbo(lp: *mut lprec, colnr: libc::c_int,
                    value: libc::c_double)
     -> libc::c_uchar;
    pub fn get_upbo(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_double;
    pub fn set_lowbo(lp: *mut lprec, colnr: libc::c_int,
                     value: libc::c_double)
     -> libc::c_uchar;
    pub fn get_lowbo(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_double;
    pub fn set_bounds(lp: *mut lprec, colnr: libc::c_int,
                      lower: libc::c_double,
                      upper: libc::c_double)
     -> libc::c_uchar;
    pub fn set_unbounded(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn is_unbounded(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_int(lp: *mut lprec, colnr: libc::c_int,
                   must_be_int: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_int(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_binary(lp: *mut lprec, colnr: libc::c_int,
                      must_be_bin: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_binary(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_semicont(lp: *mut lprec, colnr: libc::c_int,
                        must_be_sc: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_semicont(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn is_negative(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_var_weights(lp: *mut lprec,
                           weights: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_var_priority(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_int;
    pub fn set_pseudocosts(lp: *mut lprec,
                           clower: *mut libc::c_double,
                           cupper: *mut libc::c_double,
                           updatelimit: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn get_pseudocosts(lp: *mut lprec,
                           clower: *mut libc::c_double,
                           cupper: *mut libc::c_double,
                           updatelimit: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn add_SOS(lp: *mut lprec, name: *mut libc::c_char,
                   sostype: libc::c_int,
                   priority: libc::c_int,
                   count: libc::c_int,
                   sosvars: *mut libc::c_int,
                   weights: *mut libc::c_double)
     -> libc::c_int;
    pub fn is_SOS_var(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_row_name(lp: *mut lprec, rownr: libc::c_int,
                        new_name: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn get_row_name(lp: *mut lprec, rownr: libc::c_int)
     -> *mut libc::c_char;
    pub fn get_origrow_name(lp: *mut lprec, rownr: libc::c_int)
     -> *mut libc::c_char;
    pub fn set_col_name(lp: *mut lprec, colnr: libc::c_int,
                        new_name: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn get_col_name(lp: *mut lprec, colnr: libc::c_int)
     -> *mut libc::c_char;
    pub fn get_origcol_name(lp: *mut lprec, colnr: libc::c_int)
     -> *mut libc::c_char;
    pub fn unscale(lp: *mut lprec);
    pub fn set_preferdual(lp: *mut lprec, dodual: libc::c_uchar);
    pub fn set_simplextype(lp: *mut lprec,
                           simplextype: libc::c_int);
    pub fn get_simplextype(lp: *mut lprec) -> libc::c_int;
    pub fn default_basis(lp: *mut lprec);
    pub fn set_basiscrash(lp: *mut lprec, mode: libc::c_int);
    pub fn get_basiscrash(lp: *mut lprec) -> libc::c_int;
    pub fn set_basisvar(lp: *mut lprec, basisPos: libc::c_int,
                        enteringCol: libc::c_int)
     -> libc::c_int;
    pub fn set_basis(lp: *mut lprec, bascolumn: *mut libc::c_int,
                     nonbasic: libc::c_uchar)
     -> libc::c_uchar;
    pub fn get_basis(lp: *mut lprec, bascolumn: *mut libc::c_int,
                     nonbasic: libc::c_uchar)
     -> libc::c_uchar;
    pub fn reset_basis(lp: *mut lprec);
    pub fn guess_basis(lp: *mut lprec,
                       guessvector: *mut libc::c_double,
                       basisvector: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn is_feasible(lp: *mut lprec, values: *mut libc::c_double,
                       threshold: libc::c_double)
     -> libc::c_uchar;
    pub fn solve(lp: *mut lprec) -> libc::c_int;
    pub fn time_elapsed(lp: *mut lprec) -> libc::c_double;
    pub fn put_bb_nodefunc(lp: *mut lprec, newnode: lphandleint_intfunc,
                           bbnodehandle: *mut libc::c_void);
    pub fn put_bb_branchfunc(lp: *mut lprec, newbranch: lphandleint_intfunc,
                             bbbranchhandle: *mut libc::c_void);
    pub fn put_abortfunc(lp: *mut lprec, newctrlc: lphandle_intfunc,
                         ctrlchandle: *mut libc::c_void);
    pub fn put_logfunc(lp: *mut lprec, newlog: lphandlestr_func,
                       loghandle: *mut libc::c_void);
    pub fn put_msgfunc(lp: *mut lprec, newmsg: lphandleint_func,
                       msghandle: *mut libc::c_void,
                       mask: libc::c_int);
    pub fn get_primal_solution(lp: *mut lprec,
                               pv: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_primal_solution(lp: *mut lprec,
                                   pv: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_dual_solution(lp: *mut lprec,
                             rc: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_dual_solution(lp: *mut lprec,
                                 rc: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_lambda(lp: *mut lprec, lambda: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_lambda(lp: *mut lprec,
                          lambda: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn read_MPS(filename: *mut libc::c_char,
                    options: libc::c_int) -> *mut lprec;
    pub fn read_mps(filename: *mut libc::FILE, options: libc::c_int)
     -> *mut lprec;
    pub fn read_freeMPS(filename: *mut libc::c_char,
                        options: libc::c_int) -> *mut lprec;
    pub fn read_freemps(filename: *mut libc::FILE, options: libc::c_int)
     -> *mut lprec;
    pub fn write_mps(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_MPS(lp: *mut lprec, output: *mut libc::FILE)
     -> libc::c_uchar;
    pub fn write_freemps(lp: *mut lprec,
                         filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_freeMPS(lp: *mut lprec, output: *mut libc::FILE)
     -> libc::c_uchar;
    pub fn write_lp(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_LP(lp: *mut lprec, output: *mut libc::FILE)
     -> libc::c_uchar;
    pub fn LP_readhandle(lp: *mut *mut lprec, filename: *mut libc::FILE,
                         verbose: libc::c_int,
                         lp_name: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_lp(filename: *mut libc::FILE, verbose: libc::c_int,
                   lp_name: *mut libc::c_char) -> *mut lprec;
    pub fn read_LP(filename: *mut libc::c_char,
                   verbose: libc::c_int,
                   lp_name: *mut libc::c_char) -> *mut lprec;
    pub fn write_basis(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_basis(lp: *mut lprec, filename: *mut libc::c_char,
                      info: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_params(lp: *mut lprec, filename: *mut libc::c_char,
                        options: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_params(lp: *mut lprec, filename: *mut libc::c_char,
                       options: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn reset_params(lp: *mut lprec);
    pub fn print_lp(lp: *mut lprec);
    pub fn print_tableau(lp: *mut lprec);
    pub fn print_objective(lp: *mut lprec);
    pub fn print_solution(lp: *mut lprec, columns: libc::c_int);
    pub fn print_constraints(lp: *mut lprec, columns: libc::c_int);
    pub fn print_duals(lp: *mut lprec);
    pub fn print_scales(lp: *mut lprec);
    pub fn print_str(lp: *mut lprec, str: *mut libc::c_char);
    pub fn set_outputstream(lp: *mut lprec, stream: *mut libc::FILE);
    pub fn set_outputfile(lp: *mut lprec,
                          filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_verbose(lp: *mut lprec, verbose: libc::c_int);
    pub fn get_verbose(lp: *mut lprec) -> libc::c_int;
    pub fn set_timeout(lp: *mut lprec, sectimeout: libc::c_long);
    pub fn get_timeout(lp: *mut lprec) -> libc::c_long;
    pub fn set_print_sol(lp: *mut lprec, print_sol: libc::c_int);
    pub fn get_print_sol(lp: *mut lprec) -> libc::c_int;
    pub fn set_debug(lp: *mut lprec, debug: libc::c_uchar);
    pub fn is_debug(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_trace(lp: *mut lprec, trace: libc::c_uchar);
    pub fn is_trace(lp: *mut lprec) -> libc::c_uchar;
    pub fn print_debugdump(lp: *mut lprec,
                           filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_anti_degen(lp: *mut lprec, anti_degen: libc::c_int);
    pub fn get_anti_degen(lp: *mut lprec) -> libc::c_int;
    pub fn is_anti_degen(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn set_presolve(lp: *mut lprec, presolvemode: libc::c_int,
                        maxloops: libc::c_int);
    pub fn get_presolve(lp: *mut lprec) -> libc::c_int;
    pub fn get_presolveloops(lp: *mut lprec) -> libc::c_int;
    pub fn is_presolve(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn get_orig_index(lp: *mut lprec, lp_index: libc::c_int)
     -> libc::c_int;
    pub fn get_lp_index(lp: *mut lprec, orig_index: libc::c_int)
     -> libc::c_int;
    pub fn set_maxpivot(lp: *mut lprec, max_num_inv: libc::c_int);
    pub fn get_maxpivot(lp: *mut lprec) -> libc::c_int;
    pub fn set_obj_bound(lp: *mut lprec, obj_bound: libc::c_double);
    pub fn get_obj_bound(lp: *mut lprec) -> libc::c_double;
    pub fn set_mip_gap(lp: *mut lprec, absolute: libc::c_uchar,
                       mip_gap: libc::c_double);
    pub fn get_mip_gap(lp: *mut lprec, absolute: libc::c_uchar)
     -> libc::c_double;
    pub fn set_bb_rule(lp: *mut lprec, bb_rule: libc::c_int);
    pub fn get_bb_rule(lp: *mut lprec) -> libc::c_int;
    pub fn set_var_branch(lp: *mut lprec, colnr: libc::c_int,
                          branch_mode: libc::c_int)
     -> libc::c_uchar;
    pub fn get_var_branch(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_int;
    pub fn is_infinite(lp: *mut lprec, value: libc::c_double)
     -> libc::c_uchar;
    pub fn set_infinite(lp: *mut lprec, infinite: libc::c_double);
    pub fn get_infinite(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsint(lp: *mut lprec, epsint: libc::c_double);
    pub fn get_epsint(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsb(lp: *mut lprec, epsb: libc::c_double);
    pub fn get_epsb(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsd(lp: *mut lprec, epsd: libc::c_double);
    pub fn get_epsd(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsel(lp: *mut lprec, epsel: libc::c_double);
    pub fn get_epsel(lp: *mut lprec) -> libc::c_double;
    pub fn set_epslevel(lp: *mut lprec, epslevel: libc::c_int)
     -> libc::c_uchar;
    pub fn set_scaling(lp: *mut lprec, scalemode: libc::c_int);
    pub fn get_scaling(lp: *mut lprec) -> libc::c_int;
    pub fn is_scalemode(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn is_scaletype(lp: *mut lprec, scaletype: libc::c_int)
     -> libc::c_uchar;
    pub fn is_integerscaling(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_scalelimit(lp: *mut lprec,
                          scalelimit: libc::c_double);
    pub fn get_scalelimit(lp: *mut lprec) -> libc::c_double;
    pub fn set_improve(lp: *mut lprec, improve: libc::c_int);
    pub fn get_improve(lp: *mut lprec) -> libc::c_int;
    pub fn set_pivoting(lp: *mut lprec, piv_rule: libc::c_int);
    pub fn get_pivoting(lp: *mut lprec) -> libc::c_int;
    pub fn set_partialprice(lp: *mut lprec, blockcount: libc::c_int,
                            blockstart: *mut libc::c_int,
                            isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn get_partialprice(lp: *mut lprec,
                            blockcount: *mut libc::c_int,
                            blockstart: *mut libc::c_int,
                            isrow: libc::c_uchar);
    pub fn set_multiprice(lp: *mut lprec,
                          multiblockdiv: libc::c_int)
     -> libc::c_uchar;
    pub fn get_multiprice(lp: *mut lprec, getabssize: libc::c_uchar)
     -> libc::c_int;
    pub fn is_use_names(lp: *mut lprec, isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn set_use_names(lp: *mut lprec, isrow: libc::c_uchar,
                         use_names: libc::c_uchar);
    pub fn get_nameindex(lp: *mut lprec, varname: *mut libc::c_char,
                         isrow: libc::c_uchar)
     -> libc::c_int;
    pub fn is_piv_mode(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn is_piv_rule(lp: *mut lprec, rule: libc::c_int)
     -> libc::c_uchar;
    pub fn set_break_at_first(lp: *mut lprec,
                              break_at_first: libc::c_uchar);
    pub fn is_break_at_first(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_bb_floorfirst(lp: *mut lprec,
                             bb_floorfirst: libc::c_int);
    pub fn get_bb_floorfirst(lp: *mut lprec) -> libc::c_int;
    pub fn set_bb_depthlimit(lp: *mut lprec,
                             bb_maxlevel: libc::c_int);
    pub fn get_bb_depthlimit(lp: *mut lprec) -> libc::c_int;
    pub fn set_break_at_value(lp: *mut lprec,
                              break_at_value: libc::c_double);
    pub fn get_break_at_value(lp: *mut lprec) -> libc::c_double;
    pub fn set_negrange(lp: *mut lprec, negrange: libc::c_double);
    pub fn get_negrange(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsperturb(lp: *mut lprec,
                          epsperturb: libc::c_double);
    pub fn get_epsperturb(lp: *mut lprec) -> libc::c_double;
    pub fn set_epspivot(lp: *mut lprec, epspivot: libc::c_double);
    pub fn get_epspivot(lp: *mut lprec) -> libc::c_double;
    pub fn get_max_level(lp: *mut lprec) -> libc::c_int;
    pub fn get_total_nodes(lp: *mut lprec) -> libc::c_longlong;
    pub fn get_total_iter(lp: *mut lprec) -> libc::c_longlong;
    pub fn get_objective(lp: *mut lprec) -> libc::c_double;
    pub fn get_working_objective(lp: *mut lprec) -> libc::c_double;
    pub fn get_var_primalresult(lp: *mut lprec, index: libc::c_int)
     -> libc::c_double;
    pub fn get_var_dualresult(lp: *mut lprec, index: libc::c_int)
     -> libc::c_double;
    pub fn get_variables(lp: *mut lprec, var: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_variables(lp: *mut lprec,
                             var: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_constraints(lp: *mut lprec,
                           constr: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_constraints(lp: *mut lprec,
                               constr: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_sensitivity_rhs(lp: *mut lprec,
                               duals: *mut libc::c_double,
                               dualsfrom: *mut libc::c_double,
                               dualstill: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_sensitivity_rhs(lp: *mut lprec,
                                   duals: *mut *mut libc::c_double,
                                   dualsfrom:
                                       *mut *mut libc::c_double,
                                   dualstill:
                                       *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_sensitivity_obj(lp: *mut lprec,
                               objfrom: *mut libc::c_double,
                               objtill: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_sensitivity_objex(lp: *mut lprec,
                                 objfrom: *mut libc::c_double,
                                 objtill: *mut libc::c_double,
                                 objfromvalue: *mut libc::c_double,
                                 objtillvalue: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_sensitivity_obj(lp: *mut lprec,
                                   objfrom:
                                       *mut *mut libc::c_double,
                                   objtill:
                                       *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_sensitivity_objex(lp: *mut lprec,
                                     objfrom:
                                         *mut *mut libc::c_double,
                                     objtill:
                                         *mut *mut libc::c_double,
                                     objfromvalue:
                                         *mut *mut libc::c_double,
                                     objtillvalue:
                                         *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_solutionlimit(lp: *mut lprec, limit: libc::c_int);
    pub fn get_solutionlimit(lp: *mut lprec) -> libc::c_int;
    pub fn get_solutioncount(lp: *mut lprec) -> libc::c_int;
    pub fn get_Norig_rows(lp: *mut lprec) -> libc::c_int;
    pub fn get_Nrows(lp: *mut lprec) -> libc::c_int;
    pub fn get_Lrows(lp: *mut lprec) -> libc::c_int;
    pub fn get_Norig_columns(lp: *mut lprec) -> libc::c_int;
    pub fn get_Ncolumns(lp: *mut lprec) -> libc::c_int;
    pub fn MPS_readex(newlp: *mut *mut lprec,
                      userhandle: *mut libc::c_void,
                      read_modeldata: read_modeldata_func,
                      typeMPS: libc::c_int,
                      options: libc::c_int)
     -> libc::c_uchar;
    pub fn read_lpex(userhandle: *mut libc::c_void,
                     read_modeldata: read_modeldata_func,
                     verbose: libc::c_int,
                     lp_name: *mut libc::c_char) -> *mut lprec;
    pub fn write_lpex(lp: *mut lprec, userhandle: *mut libc::c_void,
                      write_modeldata: write_modeldata_func)
     -> libc::c_uchar;
    pub fn read_mpsex(userhandle: *mut libc::c_void,
                      read_modeldata: read_modeldata_func,
                      options: libc::c_int) -> *mut lprec;
    pub fn read_freempsex(userhandle: *mut libc::c_void,
                          read_modeldata: read_modeldata_func,
                          options: libc::c_int) -> *mut lprec;
    pub fn MPS_writefileex(lp: *mut lprec, typeMPS: libc::c_int,
                           userhandle: *mut libc::c_void,
                           write_modeldata: write_modeldata_func)
     -> libc::c_uchar;
    pub fn set_callbacks(lp: *mut lprec) -> libc::c_uchar;
    pub fn yieldformessages(lp: *mut lprec) -> libc::c_int;
    pub fn userabort(lp: *mut lprec, message: libc::c_int)
     -> libc::c_uchar;
    pub fn append_rows(lp: *mut lprec, deltarows: libc::c_int)
     -> libc::c_uchar;
    pub fn append_columns(lp: *mut lprec, deltacolumns: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_rows(lp: *mut lprec, delta: libc::c_int);
    pub fn inc_columns(lp: *mut lprec, delta: libc::c_int);
    pub fn init_rowcol_names(lp: *mut lprec) -> libc::c_uchar;
    pub fn inc_row_space(lp: *mut lprec, deltarows: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_col_space(lp: *mut lprec, deltacols: libc::c_int)
     -> libc::c_uchar;
    pub fn shift_rowcoldata(lp: *mut lprec, base: libc::c_int,
                            delta: libc::c_int, usedmap: *mut LLrec,
                            isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn shift_basis(lp: *mut lprec, base: libc::c_int,
                       delta: libc::c_int, usedmap: *mut LLrec,
                       isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn shift_rowdata(lp: *mut lprec, base: libc::c_int,
                         delta: libc::c_int, usedmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn shift_coldata(lp: *mut lprec, base: libc::c_int,
                         delta: libc::c_int, usedmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn is_chsign(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_lag_space(lp: *mut lprec, deltarows: libc::c_int,
                         ignoreMAT: libc::c_uchar)
     -> libc::c_uchar;
    pub fn make_lag(server: *mut lprec) -> *mut lprec;
    pub fn get_rh_upper(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn get_rh_lower(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn set_rh_upper(lp: *mut lprec, rownr: libc::c_int,
                        value: libc::c_double)
     -> libc::c_uchar;
    pub fn set_rh_lower(lp: *mut lprec, rownr: libc::c_int,
                        value: libc::c_double)
     -> libc::c_uchar;
    pub fn bin_count(lp: *mut lprec, working: libc::c_uchar)
     -> libc::c_int;
    pub fn MIP_count(lp: *mut lprec) -> libc::c_int;
    pub fn SOS_count(lp: *mut lprec) -> libc::c_int;
    pub fn GUB_count(lp: *mut lprec) -> libc::c_int;
    pub fn identify_GUB(lp: *mut lprec, mark: libc::c_uchar)
     -> libc::c_int;
    pub fn prepare_GUB(lp: *mut lprec) -> libc::c_int;
    pub fn refactRecent(lp: *mut lprec) -> libc::c_uchar;
    pub fn check_if_less(lp: *mut lprec, x: libc::c_double,
                         y: libc::c_double,
                         variable: libc::c_int)
     -> libc::c_uchar;
    pub fn feasiblePhase1(lp: *mut lprec, epsvalue: libc::c_double)
     -> libc::c_uchar;
    pub fn free_duals(lp: *mut lprec);
    pub fn initialize_solution(lp: *mut lprec,
                               shiftbounds: libc::c_uchar);
    pub fn recompute_solution(lp: *mut lprec,
                              shiftbounds: libc::c_uchar);
    pub fn verify_solution(lp: *mut lprec, reinvert: libc::c_uchar,
                           info: *mut libc::c_char)
     -> libc::c_int;
    pub fn check_solution(lp: *mut lprec, lastcolumn: libc::c_int,
                          solution: *mut libc::c_double,
                          upbo: *mut libc::c_double,
                          lowbo: *mut libc::c_double,
                          tolerance: libc::c_double)
     -> libc::c_int;
    pub fn is_fixedvar(lp: *mut lprec, variable: libc::c_int)
     -> libc::c_uchar;
    pub fn is_splitvar(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_action(actionvar: *mut libc::c_int,
                      actionmask: libc::c_int);
    pub fn clear_action(actionvar: *mut libc::c_int,
                        actionmask: libc::c_int);
    pub fn is_action(actionvar: libc::c_int,
                     testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn is_bb_rule(lp: *mut lprec, bb_rule: libc::c_int)
     -> libc::c_uchar;
    pub fn is_bb_mode(lp: *mut lprec, bb_mask: libc::c_int)
     -> libc::c_uchar;
    pub fn get_piv_rule(lp: *mut lprec) -> libc::c_int;
    pub fn get_str_piv_rule(rule: libc::c_int)
     -> *mut libc::c_char;
    pub fn set_var_priority(lp: *mut lprec) -> libc::c_uchar;
    pub fn find_sc_bbvar(lp: *mut lprec, count: *mut libc::c_int)
     -> libc::c_int;
    pub fn find_sos_bbvar(lp: *mut lprec, count: *mut libc::c_int,
                          intsos: libc::c_uchar)
     -> libc::c_int;
    pub fn find_int_bbvar(lp: *mut lprec, count: *mut libc::c_int,
                          BB: *mut BBrec,
                          isfeasible: *mut libc::c_uchar)
     -> libc::c_int;
    pub fn compute_dualslacks(lp: *mut lprec, target: libc::c_int,
                              dvalues: *mut *mut libc::c_double,
                              nzdvalues: *mut *mut libc::c_int,
                              dosum: libc::c_uchar)
     -> libc::c_double;
    pub fn solution_is_int(lp: *mut lprec, index: libc::c_int,
                           checkfixed: libc::c_uchar)
     -> libc::c_uchar;
    pub fn bb_better(lp: *mut lprec, target: libc::c_int,
                     mode: libc::c_int) -> libc::c_uchar;
    pub fn construct_solution(lp: *mut lprec,
                              target: *mut libc::c_double);
    pub fn transfer_solution_var(lp: *mut lprec,
                                 uservar: libc::c_int);
    pub fn construct_duals(lp: *mut lprec) -> libc::c_uchar;
    pub fn construct_sensitivity_duals(lp: *mut lprec)
     -> libc::c_uchar;
    pub fn construct_sensitivity_obj(lp: *mut lprec)
     -> libc::c_uchar;
    pub fn add_GUB(lp: *mut lprec, name: *mut libc::c_char,
                   priority: libc::c_int,
                   count: libc::c_int,
                   sosvars: *mut libc::c_int)
     -> libc::c_int;
    pub fn push_basis(lp: *mut lprec, basisvar: *mut libc::c_int,
                      isbasic: *mut libc::c_uchar,
                      islower: *mut libc::c_uchar) -> *mut basisrec;
    pub fn compare_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn restore_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn pop_basis(lp: *mut lprec, restore: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_BasisReady(lp: *mut lprec) -> libc::c_uchar;
    pub fn is_slackbasis(lp: *mut lprec) -> libc::c_uchar;
    pub fn verify_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn unload_basis(lp: *mut lprec, restorelast: libc::c_uchar)
     -> libc::c_int;
    pub fn perturb_bounds(lp: *mut lprec, perturbed: *mut BBrec,
                          doRows: libc::c_uchar,
                          doCols: libc::c_uchar,
                          includeFIXED: libc::c_uchar)
     -> libc::c_int;
    pub fn validate_bounds(lp: *mut lprec,
                           upbo: *mut libc::c_double,
                           lowbo: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn impose_bounds(lp: *mut lprec, upbo: *mut libc::c_double,
                         lowbo: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn unload_BB(lp: *mut lprec) -> libc::c_int;
    pub fn feasibilityOffset(lp: *mut lprec, isdual: libc::c_uchar)
     -> libc::c_double;
    pub fn isP1extra(lp: *mut lprec) -> libc::c_uchar;
    pub fn get_refactfrequency(lp: *mut lprec,
                               _final: libc::c_uchar)
     -> libc::c_double;
    pub fn findBasicFixedvar(lp: *mut lprec, afternr: libc::c_int,
                             slacksonly: libc::c_uchar)
     -> libc::c_int;
    pub fn isBasisVarFeasible(lp: *mut lprec, tol: libc::c_double,
                              basis_row: libc::c_int)
     -> libc::c_uchar;
    pub fn isPrimalFeasible(lp: *mut lprec, tol: libc::c_double,
                            infeasibles: *mut libc::c_int,
                            feasibilitygap: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn isDualFeasible(lp: *mut lprec, tol: libc::c_double,
                          boundflips: *mut libc::c_int,
                          infeasibles: *mut libc::c_int,
                          feasibilitygap: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn preprocess(lp: *mut lprec) -> libc::c_int;
    pub fn postprocess(lp: *mut lprec);
    pub fn performiteration(lp: *mut lprec, rownr: libc::c_int,
                            varin: libc::c_int,
                            theta: libc::c_double,
                            primal: libc::c_uchar,
                            allowminit: libc::c_uchar,
                            prow: *mut libc::c_double,
                            nzprow: *mut libc::c_int,
                            pcol: *mut libc::c_double,
                            nzpcol: *mut libc::c_int,
                            boundswaps: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn transfer_solution(lp: *mut lprec,
                             dofinal: libc::c_uchar);
    pub fn scaled_floor(lp: *mut lprec, colnr: libc::c_int,
                        value: libc::c_double,
                        epsscale: libc::c_double)
     -> libc::c_double;
    pub fn scaled_ceil(lp: *mut lprec, colnr: libc::c_int,
                       value: libc::c_double,
                       epsscale: libc::c_double)
     -> libc::c_double;
    pub fn varmap_lock(lp: *mut lprec);
    pub fn varmap_clear(lp: *mut lprec);
    pub fn varmap_canunlock(lp: *mut lprec) -> libc::c_uchar;
    pub fn varmap_addconstraint(lp: *mut lprec);
    pub fn varmap_addcolumn(lp: *mut lprec);
    pub fn varmap_delete(lp: *mut lprec, base: libc::c_int,
                         delta: libc::c_int, varmap: *mut LLrec);
    pub fn varmap_compact(lp: *mut lprec, prev_rows: libc::c_int,
                          prev_cols: libc::c_int);
    pub fn varmap_validate(lp: *mut lprec, varno: libc::c_int)
     -> libc::c_uchar;
    pub fn del_varnameex(lp: *mut lprec, namelist: *mut *mut hashelem,
                         items: libc::c_int, ht: *mut hashtable,
                         varnr: libc::c_int, varmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn init_pseudocost(lp: *mut lprec, pseudotype: libc::c_int)
     -> *mut BBPSrec;
    pub fn free_pseudocost(lp: *mut lprec);
    pub fn get_pseudorange(pc: *mut BBPSrec, mipvar: libc::c_int,
                           varcode: libc::c_int)
     -> libc::c_double;
    pub fn update_pseudocost(pc: *mut BBPSrec, mipvar: libc::c_int,
                             varcode: libc::c_int,
                             capupper: libc::c_uchar,
                             varsol: libc::c_double);
    pub fn get_pseudobranchcost(pc: *mut BBPSrec,
                                mipvar: libc::c_int,
                                dofloor: libc::c_uchar)
     -> libc::c_double;
    pub fn get_pseudonodecost(pc: *mut BBPSrec, mipvar: libc::c_int,
                              vartype: libc::c_int,
                              varsol: libc::c_double)
     -> libc::c_double;
    pub fn set_OF_override(lp: *mut lprec,
                           ofVector: *mut libc::c_double);
    pub fn set_OF_p1extra(lp: *mut lprec, p1extra: libc::c_double);
    pub fn unset_OF_p1extra(lp: *mut lprec);
    pub fn modifyOF1(lp: *mut lprec, index: libc::c_int,
                     ofValue: *mut libc::c_double,
                     mult: libc::c_double)
     -> libc::c_uchar;
    pub fn get_OF_active(lp: *mut lprec, varnr: libc::c_int,
                         mult: libc::c_double)
     -> libc::c_double;
    pub fn is_OF_nz(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn get_basisOF(lp: *mut lprec, coltarget: *mut libc::c_int,
                       crow: *mut libc::c_double,
                       colno: *mut libc::c_int)
     -> libc::c_int;
    pub fn get_basiscolumn(lp: *mut lprec, j: libc::c_int,
                           rn: *mut libc::c_int,
                           bj: *mut libc::c_double)
     -> libc::c_int;
    pub fn obtain_column(lp: *mut lprec, varin: libc::c_int,
                         pcol: *mut libc::c_double,
                         nzlist: *mut libc::c_int,
                         maxabs: *mut libc::c_int)
     -> libc::c_int;
    pub fn compute_theta(lp: *mut lprec, rownr: libc::c_int,
                         theta: *mut libc::c_double,
                         isupbound: libc::c_int,
                         HarrisScalar: libc::c_double,
                         primal: libc::c_uchar)
     -> libc::c_int;
    pub fn findBasisPos(lp: *mut lprec, notint: libc::c_int,
                        var_basic: *mut libc::c_int)
     -> libc::c_int;
    pub fn check_degeneracy(lp: *mut lprec,
                            pcol: *mut libc::c_double,
                            degencount: *mut libc::c_int)
     -> libc::c_uchar;
}

#[cfg(windows)]
#[link(name = "lpsolve55")]
extern "stdcall" {
    pub fn allocCHAR(lp: *mut lprec, ptr: *mut *mut libc::c_char,
                     size: libc::c_int,
                     clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocMYBOOL(lp: *mut lprec, ptr: *mut *mut libc::c_uchar,
                       size: libc::c_int,
                       clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocINT(lp: *mut lprec, ptr: *mut *mut libc::c_int,
                    size: libc::c_int,
                    clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocREAL(lp: *mut lprec, ptr: *mut *mut libc::c_double,
                     size: libc::c_int,
                     clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocLREAL(lp: *mut lprec, ptr: *mut *mut libc::c_double,
                      size: libc::c_int,
                      clear: libc::c_uchar)
     -> libc::c_uchar;
    pub fn allocFREE(lp: *mut lprec, ptr: *mut *mut libc::c_void)
     -> libc::c_uchar;
    pub fn cloneREAL(lp: *mut lprec, origlist: *mut libc::c_double,
                     size: libc::c_int)
     -> *mut libc::c_double;
    pub fn cloneMYBOOL(lp: *mut lprec, origlist: *mut libc::c_uchar,
                       size: libc::c_int)
     -> *mut libc::c_uchar;
    pub fn cloneINT(lp: *mut lprec, origlist: *mut libc::c_int,
                    size: libc::c_int)
     -> *mut libc::c_int;
    pub fn comp_bits(bitarray1: *mut libc::c_uchar,
                     bitarray2: *mut libc::c_uchar,
                     items: libc::c_int) -> libc::c_int;
    pub fn mempool_create(lp: *mut lprec) -> *mut workarraysrec;
    pub fn mempool_obtainVector(mempool: *mut workarraysrec,
                                count: libc::c_int,
                                unitsize: libc::c_int)
     -> *mut libc::c_char;
    pub fn mempool_releaseVector(mempool: *mut workarraysrec,
                                 memvector: *mut libc::c_char,
                                 forcefree: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mempool_free(mempool: *mut *mut workarraysrec)
     -> libc::c_uchar;
    pub fn roundVector(myvector: *mut libc::c_double,
                       endpos: libc::c_int,
                       roundzero: libc::c_double);
    pub fn normalizeVector(myvector: *mut libc::c_double,
                           endpos: libc::c_int)
     -> libc::c_double;
    pub fn swapINT(item1: *mut libc::c_int,
                   item2: *mut libc::c_int);
    pub fn swapREAL(item1: *mut libc::c_double,
                    item2: *mut libc::c_double);
    pub fn swapPTR(item1: *mut *mut libc::c_void,
                   item2: *mut *mut libc::c_void);
    pub fn restoreINT(valREAL: libc::c_double,
                      epsilon: libc::c_double)
     -> libc::c_double;
    pub fn roundToPrecision(value: libc::c_double,
                            precision: libc::c_double)
     -> libc::c_double;
    pub fn searchFor(target: libc::c_int,
                     attributes: *mut libc::c_int,
                     size: libc::c_int,
                     offset: libc::c_int,
                     absolute: libc::c_uchar)
     -> libc::c_int;
    pub fn isINT(lp: *mut lprec, value: libc::c_double)
     -> libc::c_uchar;
    pub fn isOrigFixed(lp: *mut lprec, varno: libc::c_int)
     -> libc::c_uchar;
    pub fn chsign_bounds(lobound: *mut libc::c_double,
                         upbound: *mut libc::c_double);
    pub fn rand_uniform(lp: *mut lprec, range: libc::c_double)
     -> libc::c_double;
    pub fn createLink(size: libc::c_int, linkmap: *mut *mut LLrec,
                      usedpos: *mut libc::c_uchar)
     -> libc::c_int;
    pub fn freeLink(linkmap: *mut *mut LLrec) -> libc::c_uchar;
    pub fn sizeLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn isActiveLink(linkmap: *mut LLrec, itemnr: libc::c_int)
     -> libc::c_uchar;
    pub fn countActiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn countInactiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn firstActiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn lastActiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn appendLink(linkmap: *mut LLrec, newitem: libc::c_int)
     -> libc::c_uchar;
    pub fn insertLink(linkmap: *mut LLrec, afteritem: libc::c_int,
                      newitem: libc::c_int)
     -> libc::c_uchar;
    pub fn setLink(linkmap: *mut LLrec, newitem: libc::c_int)
     -> libc::c_uchar;
    pub fn fillLink(linkmap: *mut LLrec) -> libc::c_uchar;
    pub fn nextActiveLink(linkmap: *mut LLrec,
                          backitemnr: libc::c_int)
     -> libc::c_int;
    pub fn prevActiveLink(linkmap: *mut LLrec,
                          forwitemnr: libc::c_int)
     -> libc::c_int;
    pub fn firstInactiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn lastInactiveLink(linkmap: *mut LLrec) -> libc::c_int;
    pub fn nextInactiveLink(linkmap: *mut LLrec,
                            backitemnr: libc::c_int)
     -> libc::c_int;
    pub fn prevInactiveLink(linkmap: *mut LLrec,
                            forwitemnr: libc::c_int)
     -> libc::c_int;
    pub fn removeLink(linkmap: *mut LLrec, itemnr: libc::c_int)
     -> libc::c_int;
    pub fn cloneLink(sourcemap: *mut LLrec, newsize: libc::c_int,
                     freesource: libc::c_uchar) -> *mut LLrec;
    pub fn compareLink(linkmap1: *mut LLrec, linkmap2: *mut LLrec)
     -> libc::c_int;
    pub fn verifyLink(linkmap: *mut LLrec, itemnr: libc::c_int,
                      doappend: libc::c_uchar)
     -> libc::c_uchar;
    pub fn createPackedVector(size: libc::c_int,
                              values: *mut libc::c_double,
                              workvector: *mut libc::c_int)
     -> *mut PVrec;
    pub fn pushPackedVector(PV: *mut PVrec, parent: *mut PVrec);
    pub fn unpackPackedVector(PV: *mut PVrec,
                              target: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn getvaluePackedVector(PV: *mut PVrec, index: libc::c_int)
     -> libc::c_double;
    pub fn popPackedVector(PV: *mut PVrec) -> *mut PVrec;
    pub fn freePackedVector(PV: *mut *mut PVrec) -> libc::c_uchar;
    pub fn create_hash_table(size: libc::c_int,
                             base: libc::c_int) -> *mut hashtable;
    pub fn free_hash_table(ht: *mut hashtable);
    pub fn findhash(name: *const libc::c_char, ht: *mut hashtable)
     -> *mut hashelem;
    pub fn puthash(name: *const libc::c_char,
                   index: libc::c_int, list: *mut *mut hashelem,
                   ht: *mut hashtable) -> *mut hashelem;
    pub fn drophash(name: *const libc::c_char,
                    list: *mut *mut hashelem, ht: *mut hashtable);
    pub fn free_hash_item(hp: *mut *mut hashelem);
    pub fn copy_hash_table(ht: *mut hashtable, list: *mut *mut hashelem,
                           newsize: libc::c_int) -> *mut hashtable;
    pub fn find_var(lp: *mut lprec, name: *mut libc::c_char,
                    verbose: libc::c_uchar)
     -> libc::c_int;
    pub fn find_row(lp: *mut lprec, name: *mut libc::c_char,
                    Unconstrained_rows_found: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_create(lp: *mut lprec, rows: libc::c_int,
                      columns: libc::c_int,
                      epsvalue: libc::c_double) -> *mut MATrec;
    pub fn mat_memopt(mat: *mut MATrec, rowextra: libc::c_int,
                      colextra: libc::c_int,
                      nzextra: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_free(matrix: *mut *mut MATrec);
    pub fn inc_matrow_space(mat: *mut MATrec,
                            deltarows: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_mapreplace(mat: *mut MATrec, rowmap: *mut LLrec,
                          colmap: *mut LLrec, insmat: *mut MATrec)
     -> libc::c_int;
    pub fn mat_matinsert(mat: *mut MATrec, insmat: *mut MATrec)
     -> libc::c_int;
    pub fn mat_zerocompact(mat: *mut MATrec) -> libc::c_int;
    pub fn mat_rowcompact(mat: *mut MATrec, dozeros: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_colcompact(mat: *mut MATrec, prev_rows: libc::c_int,
                          prev_cols: libc::c_int)
     -> libc::c_int;
    pub fn inc_matcol_space(mat: *mut MATrec,
                            deltacols: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_mat_space(mat: *mut MATrec, mindelta: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_shiftrows(mat: *mut MATrec, bbase: *mut libc::c_int,
                         delta: libc::c_int, varmap: *mut LLrec)
     -> libc::c_int;
    pub fn mat_shiftcols(mat: *mut MATrec, bbase: *mut libc::c_int,
                         delta: libc::c_int, varmap: *mut LLrec)
     -> libc::c_int;
    pub fn mat_extractmat(mat: *mut MATrec, rowmap: *mut LLrec,
                          colmap: *mut LLrec,
                          negated: libc::c_uchar) -> *mut MATrec;
    pub fn mat_appendrow(mat: *mut MATrec, count: libc::c_int,
                         row: *mut libc::c_double,
                         colno: *mut libc::c_int,
                         mult: libc::c_double,
                         checkrowmode: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_appendcol(mat: *mut MATrec, count: libc::c_int,
                         column: *mut libc::c_double,
                         rowno: *mut libc::c_int,
                         mult: libc::c_double,
                         checkrowmode: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_get_data(lp: *mut lprec, matindex: libc::c_int,
                        isrow: libc::c_uchar,
                        rownr: *mut *mut libc::c_int,
                        colnr: *mut *mut libc::c_int,
                        value: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn mat_set_rowmap(mat: *mut MATrec,
                          row_mat_index: libc::c_int,
                          rownr: libc::c_int,
                          colnr: libc::c_int,
                          col_mat_index: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_indexrange(mat: *mut MATrec, index: libc::c_int,
                          isrow: libc::c_uchar,
                          startpos: *mut libc::c_int,
                          endpos: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn mat_validate(mat: *mut MATrec) -> libc::c_uchar;
    pub fn mat_equalRows(mat: *mut MATrec, baserow: libc::c_int,
                         comprow: libc::c_int)
     -> libc::c_uchar;
    pub fn mat_findelm(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int)
     -> libc::c_int;
    pub fn mat_findins(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int,
                       insertpos: *mut libc::c_int,
                       validate: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_multcol(mat: *mut MATrec, col_nr: libc::c_int,
                       mult: libc::c_double,
                       DoObj: libc::c_uchar);
    pub fn mat_getitem(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int)
     -> libc::c_double;
    pub fn mat_setitem(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int,
                       value: libc::c_double)
     -> libc::c_uchar;
    pub fn mat_additem(mat: *mut MATrec, row: libc::c_int,
                       column: libc::c_int,
                       delta: libc::c_double)
     -> libc::c_uchar;
    pub fn mat_setvalue(mat: *mut MATrec, Row: libc::c_int,
                        Column: libc::c_int,
                        Value: libc::c_double,
                        doscale: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_nonzeros(mat: *mut MATrec) -> libc::c_int;
    pub fn mat_collength(mat: *mut MATrec, colnr: libc::c_int)
     -> libc::c_int;
    pub fn mat_rowlength(mat: *mut MATrec, rownr: libc::c_int)
     -> libc::c_int;
    pub fn mat_multrow(mat: *mut MATrec, row_nr: libc::c_int,
                       mult: libc::c_double);
    pub fn mat_multadd(mat: *mut MATrec,
                       lhsvector: *mut libc::c_double,
                       varnr: libc::c_int,
                       mult: libc::c_double);
    pub fn mat_setrow(mat: *mut MATrec, rowno: libc::c_int,
                      count: libc::c_int,
                      row: *mut libc::c_double,
                      colno: *mut libc::c_int,
                      doscale: libc::c_uchar,
                      checkrowmode: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_setcol(mat: *mut MATrec, colno: libc::c_int,
                      count: libc::c_int,
                      column: *mut libc::c_double,
                      rowno: *mut libc::c_int,
                      doscale: libc::c_uchar,
                      checkrowmode: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_mergemat(target: *mut MATrec, source: *mut MATrec,
                        usecolmap: libc::c_uchar)
     -> libc::c_uchar;
    pub fn mat_checkcounts(mat: *mut MATrec,
                           rownum: *mut libc::c_int,
                           colnum: *mut libc::c_int,
                           freeonexit: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_expandcolumn(mat: *mut MATrec, colnr: libc::c_int,
                            column: *mut libc::c_double,
                            nzlist: *mut libc::c_int,
                            signedA: libc::c_uchar)
     -> libc::c_int;
    pub fn mat_computemax(mat: *mut MATrec) -> libc::c_uchar;
    pub fn mat_transpose(mat: *mut MATrec) -> libc::c_uchar;
    pub fn invert(lp: *mut lprec, shiftbounds: libc::c_uchar,
                  _final: libc::c_uchar) -> libc::c_uchar;
    pub fn vec_compress(densevector: *mut libc::c_double,
                        startpos: libc::c_int,
                        endpos: libc::c_int,
                        epsilon: libc::c_double,
                        nzvector: *mut libc::c_double,
                        nzindex: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn vec_expand(nzvector: *mut libc::c_double,
                      nzindex: *mut libc::c_int,
                      densevector: *mut libc::c_double,
                      startpos: libc::c_int,
                      endpos: libc::c_int)
     -> libc::c_uchar;
    pub fn get_colIndexA(lp: *mut lprec, varset: libc::c_int,
                         colindex: *mut libc::c_int,
                         append: libc::c_uchar)
     -> libc::c_uchar;
    pub fn prod_Ax(lp: *mut lprec, coltarget: *mut libc::c_int,
                   input: *mut libc::c_double,
                   nzinput: *mut libc::c_int,
                   roundzero: libc::c_double,
                   ofscalar: libc::c_double,
                   output: *mut libc::c_double,
                   nzoutput: *mut libc::c_int,
                   roundmode: libc::c_int) -> libc::c_int;
    pub fn prod_xA(lp: *mut lprec, coltarget: *mut libc::c_int,
                   input: *mut libc::c_double,
                   nzinput: *mut libc::c_int,
                   roundzero: libc::c_double,
                   ofscalar: libc::c_double,
                   output: *mut libc::c_double,
                   nzoutput: *mut libc::c_int,
                   roundmode: libc::c_int) -> libc::c_int;
    pub fn prod_xA2(lp: *mut lprec, coltarget: *mut libc::c_int,
                    prow: *mut libc::c_double,
                    proundzero: libc::c_double,
                    pnzprow: *mut libc::c_int,
                    drow: *mut libc::c_double,
                    droundzero: libc::c_double,
                    dnzdrow: *mut libc::c_int,
                    ofscalar: libc::c_double,
                    roundmode: libc::c_int)
     -> libc::c_uchar;
    pub fn fimprove(lp: *mut lprec, pcol: *mut libc::c_double,
                    nzidx: *mut libc::c_int,
                    roundzero: libc::c_double)
     -> libc::c_uchar;
    pub fn ftran(lp: *mut lprec, rhsvector: *mut libc::c_double,
                 nzidx: *mut libc::c_int,
                 roundzero: libc::c_double);
    pub fn bimprove(lp: *mut lprec, rhsvector: *mut libc::c_double,
                    nzidx: *mut libc::c_int,
                    roundzero: libc::c_double)
     -> libc::c_uchar;
    pub fn btran(lp: *mut lprec, rhsvector: *mut libc::c_double,
                 nzidx: *mut libc::c_int,
                 roundzero: libc::c_double);
    pub fn fsolve(lp: *mut lprec, varin: libc::c_int,
                  pcol: *mut libc::c_double,
                  nzidx: *mut libc::c_int,
                  roundzero: libc::c_double,
                  ofscalar: libc::c_double,
                  prepareupdate: libc::c_uchar)
     -> libc::c_uchar;
    pub fn bsolve(lp: *mut lprec, row_nr: libc::c_int,
                  rhsvector: *mut libc::c_double,
                  nzidx: *mut libc::c_int,
                  roundzero: libc::c_double,
                  ofscalar: libc::c_double)
     -> libc::c_uchar;
    pub fn bsolve_xA2(lp: *mut lprec, coltarget: *mut libc::c_int,
                      row_nr1: libc::c_int,
                      vector1: *mut libc::c_double,
                      roundzero1: libc::c_double,
                      nzvector1: *mut libc::c_int,
                      row_nr2: libc::c_int,
                      vector2: *mut libc::c_double,
                      roundzero2: libc::c_double,
                      nzvector2: *mut libc::c_int,
                      roundmode: libc::c_int);
    pub fn createUndoLadder(lp: *mut lprec, levelitems: libc::c_int,
                            maxlevels: libc::c_int)
     -> *mut DeltaVrec;
    pub fn incrementUndoLadder(DV: *mut DeltaVrec) -> libc::c_int;
    pub fn modifyUndoLadder(DV: *mut DeltaVrec, itemno: libc::c_int,
                            target: *mut libc::c_double,
                            newvalue: libc::c_double)
     -> libc::c_uchar;
    pub fn countsUndoLadder(DV: *mut DeltaVrec) -> libc::c_int;
    pub fn restoreUndoLadder(DV: *mut DeltaVrec,
                             target: *mut libc::c_double)
     -> libc::c_int;
    pub fn decrementUndoLadder(DV: *mut DeltaVrec) -> libc::c_int;
    pub fn freeUndoLadder(DV: *mut *mut DeltaVrec) -> libc::c_uchar;
    pub fn appendUndoPresolve(lp: *mut lprec,
                              isprimal: libc::c_uchar,
                              beta: libc::c_double,
                              colnrDep: libc::c_int)
     -> libc::c_uchar;
    pub fn addUndoPresolve(lp: *mut lprec, isprimal: libc::c_uchar,
                           colnrElim: libc::c_int,
                           alpha: libc::c_double,
                           beta: libc::c_double,
                           colnrDep: libc::c_int)
     -> libc::c_uchar;
    pub fn create_BB(lp: *mut lprec, parentBB: *mut BBrec,
                     dofullcopy: libc::c_uchar) -> *mut BBrec;
    pub fn push_BB(lp: *mut lprec, parentBB: *mut BBrec,
                   varno: libc::c_int,
                   vartype: libc::c_int,
                   varcus: libc::c_int) -> *mut BBrec;
    pub fn initbranches_BB(BB: *mut BBrec) -> libc::c_uchar;
    pub fn fillbranches_BB(BB: *mut BBrec) -> libc::c_uchar;
    pub fn nextbranch_BB(BB: *mut BBrec) -> libc::c_uchar;
    pub fn strongbranch_BB(lp: *mut lprec, BB: *mut BBrec,
                           varno: libc::c_int,
                           vartype: libc::c_int,
                           varcus: libc::c_int)
     -> libc::c_uchar;
    pub fn initcuts_BB(lp: *mut lprec) -> libc::c_uchar;
    pub fn updatecuts_BB(lp: *mut lprec) -> libc::c_int;
    pub fn freecuts_BB(lp: *mut lprec) -> libc::c_uchar;
    pub fn findself_BB(BB: *mut BBrec) -> *mut BBrec;
    pub fn solve_LP(lp: *mut lprec, BB: *mut BBrec) -> libc::c_int;
    pub fn rcfbound_BB(BB: *mut BBrec, varno: libc::c_int,
                       isINT: libc::c_uchar,
                       newbound: *mut libc::c_double,
                       isfeasible: *mut libc::c_uchar)
     -> libc::c_int;
    pub fn findnode_BB(BB: *mut BBrec, varno: *mut libc::c_int,
                       vartype: *mut libc::c_int,
                       varcus: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn solve_BB(BB: *mut BBrec) -> libc::c_int;
    pub fn free_BB(BB: *mut *mut BBrec) -> libc::c_uchar;
    pub fn pop_BB(BB: *mut BBrec) -> *mut BBrec;
    pub fn run_BB(lp: *mut lprec) -> libc::c_int;
    pub fn create_SOSgroup(lp: *mut lprec) -> *mut SOSgroup;
    pub fn resize_SOSgroup(group: *mut SOSgroup);
    pub fn append_SOSgroup(group: *mut SOSgroup, SOS: *mut SOSrec)
     -> libc::c_int;
    pub fn clean_SOSgroup(group: *mut SOSgroup,
                          forceupdatemap: libc::c_uchar)
     -> libc::c_int;
    pub fn free_SOSgroup(group: *mut *mut SOSgroup);
    pub fn create_SOSrec(group: *mut SOSgroup,
                         name: *mut libc::c_char,
                         _type: libc::c_int,
                         priority: libc::c_int,
                         size: libc::c_int,
                         variables: *mut libc::c_int,
                         weights: *mut libc::c_double)
     -> *mut SOSrec;
    pub fn delete_SOSrec(group: *mut SOSgroup,
                         sosindex: libc::c_int)
     -> libc::c_uchar;
    pub fn append_SOSrec(SOS: *mut SOSrec, size: libc::c_int,
                         variables: *mut libc::c_int,
                         weights: *mut libc::c_double)
     -> libc::c_int;
    pub fn free_SOSrec(SOS: *mut SOSrec);
    pub fn make_SOSchain(lp: *mut lprec, forceresort: libc::c_uchar)
     -> libc::c_int;
    pub fn SOS_member_updatemap(group: *mut SOSgroup)
     -> libc::c_int;
    pub fn SOS_member_sortlist(group: *mut SOSgroup,
                               sosindex: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_shift_col(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int,
                         delta: libc::c_int, usedmap: *mut LLrec,
                         forceresort: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_member_delete(group: *mut SOSgroup,
                             sosindex: libc::c_int,
                             member: libc::c_int)
     -> libc::c_int;
    pub fn SOS_get_type(group: *mut SOSgroup, sosindex: libc::c_int)
     -> libc::c_int;
    pub fn SOS_infeasible(group: *mut SOSgroup,
                          sosindex: libc::c_int)
     -> libc::c_int;
    pub fn SOS_member_index(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            member: libc::c_int)
     -> libc::c_int;
    pub fn SOS_member_count(group: *mut SOSgroup,
                            sosindex: libc::c_int)
     -> libc::c_int;
    pub fn SOS_memberships(group: *mut SOSgroup,
                           column: libc::c_int)
     -> libc::c_int;
    pub fn SOS_get_candidates(group: *mut SOSgroup,
                              sosindex: libc::c_int,
                              column: libc::c_int,
                              excludetarget: libc::c_uchar,
                              upbound: *mut libc::c_double,
                              lobound: *mut libc::c_double)
     -> *mut libc::c_int;
    pub fn SOS_is_member(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int)
     -> libc::c_int;
    pub fn SOS_is_member_of_type(group: *mut SOSgroup,
                                 column: libc::c_int,
                                 sostype: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_set_GUB(group: *mut SOSgroup, sosindex: libc::c_int,
                       state: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_is_GUB(group: *mut SOSgroup, sosindex: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_is_marked(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_is_active(group: *mut SOSgroup,
                         sosindex: libc::c_int,
                         column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_is_full(group: *mut SOSgroup, sosindex: libc::c_int,
                       column: libc::c_int,
                       activeonly: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_can_activate(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_set_marked(group: *mut SOSgroup,
                          sosindex: libc::c_int,
                          column: libc::c_int,
                          asactive: libc::c_uchar)
     -> libc::c_uchar;
    pub fn SOS_unmark(group: *mut SOSgroup, sosindex: libc::c_int,
                      column: libc::c_int)
     -> libc::c_uchar;
    pub fn SOS_fix_unmarked(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            variable: libc::c_int,
                            bound: *mut libc::c_double,
                            value: libc::c_double,
                            isupper: libc::c_uchar,
                            diffcount: *mut libc::c_int,
                            changelog: *mut DeltaVrec)
     -> libc::c_int;
    pub fn SOS_fix_list(group: *mut SOSgroup, sosindex: libc::c_int,
                        variable: libc::c_int,
                        bound: *mut libc::c_double,
                        varlist: *mut libc::c_int,
                        isleft: libc::c_uchar,
                        changelog: *mut DeltaVrec) -> libc::c_int;
    pub fn SOS_is_satisfied(group: *mut SOSgroup,
                            sosindex: libc::c_int,
                            solution: *mut libc::c_double)
     -> libc::c_int;
    pub fn SOS_is_feasible(group: *mut SOSgroup,
                           sosindex: libc::c_int,
                           solution: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn lp_solve_version(majorversion: *mut libc::c_int,
                            minorversion: *mut libc::c_int,
                            release: *mut libc::c_int,
                            build: *mut libc::c_int);
    pub fn make_lp(rows: libc::c_int,
                   columns: libc::c_int) -> *mut lprec;
    pub fn resize_lp(lp: *mut lprec, rows: libc::c_int,
                     columns: libc::c_int)
     -> libc::c_uchar;
    pub fn get_status(lp: *mut lprec) -> libc::c_int;
    pub fn get_statustext(lp: *mut lprec, statuscode: libc::c_int)
     -> *mut libc::c_char;
    pub fn is_obj_in_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_obj_in_basis(lp: *mut lprec,
                            obj_in_basis: libc::c_uchar);
    pub fn copy_lp(lp: *mut lprec) -> *mut lprec;
    pub fn dualize_lp(lp: *mut lprec) -> libc::c_uchar;
    pub fn memopt_lp(lp: *mut lprec, rowextra: libc::c_int,
                     colextra: libc::c_int,
                     nzextra: libc::c_int)
     -> libc::c_uchar;
    pub fn delete_lp(lp: *mut lprec);
    pub fn free_lp(plp: *mut *mut lprec);
    pub fn set_lp_name(lp: *mut lprec, lpname: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn get_lp_name(lp: *mut lprec) -> *mut libc::c_char;
    pub fn has_BFP(lp: *mut lprec) -> libc::c_uchar;
    pub fn is_nativeBFP(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_BFP(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_XLI(xliname: *mut libc::c_char,
                    modelname: *mut libc::c_char,
                    dataname: *mut libc::c_char,
                    options: *mut libc::c_char,
                    verbose: libc::c_int) -> *mut lprec;
    pub fn write_XLI(lp: *mut lprec, filename: *mut libc::c_char,
                     options: *mut libc::c_char,
                     results: libc::c_uchar)
     -> libc::c_uchar;
    pub fn has_XLI(lp: *mut lprec) -> libc::c_uchar;
    pub fn is_nativeXLI(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_XLI(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_obj(lp: *mut lprec, colnr: libc::c_int,
                   value: libc::c_double)
     -> libc::c_uchar;
    pub fn set_obj_fn(lp: *mut lprec, row: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_obj_fnex(lp: *mut lprec, count: libc::c_int,
                        row: *mut libc::c_double,
                        colno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn str_set_obj_fn(lp: *mut lprec,
                          row_string: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_sense(lp: *mut lprec, maximize: libc::c_uchar);
    pub fn set_maxim(lp: *mut lprec);
    pub fn set_minim(lp: *mut lprec);
    pub fn is_maxim(lp: *mut lprec) -> libc::c_uchar;
    pub fn add_constraint(lp: *mut lprec, row: *mut libc::c_double,
                          constr_type: libc::c_int,
                          rh: libc::c_double)
     -> libc::c_uchar;
    pub fn add_constraintex(lp: *mut lprec, count: libc::c_int,
                            row: *mut libc::c_double,
                            colno: *mut libc::c_int,
                            constr_type: libc::c_int,
                            rh: libc::c_double)
     -> libc::c_uchar;
    pub fn set_add_rowmode(lp: *mut lprec, turnon: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_add_rowmode(lp: *mut lprec) -> libc::c_uchar;
    pub fn str_add_constraint(lp: *mut lprec,
                              row_string: *mut libc::c_char,
                              constr_type: libc::c_int,
                              rh: libc::c_double)
     -> libc::c_uchar;
    pub fn set_row(lp: *mut lprec, rownr: libc::c_int,
                   row: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_rowex(lp: *mut lprec, rownr: libc::c_int,
                     count: libc::c_int,
                     row: *mut libc::c_double,
                     colno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn get_row(lp: *mut lprec, rownr: libc::c_int,
                   row: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_rowex(lp: *mut lprec, rownr: libc::c_int,
                     row: *mut libc::c_double,
                     colno: *mut libc::c_int)
     -> libc::c_int;
    pub fn del_constraint(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_uchar;
    pub fn del_constraintex(lp: *mut lprec, rowmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn add_lag_con(lp: *mut lprec, row: *mut libc::c_double,
                       con_type: libc::c_int,
                       rhs: libc::c_double)
     -> libc::c_uchar;
    pub fn str_add_lag_con(lp: *mut lprec,
                           row_string: *mut libc::c_char,
                           con_type: libc::c_int,
                           rhs: libc::c_double)
     -> libc::c_uchar;
    pub fn set_lag_trace(lp: *mut lprec, lag_trace: libc::c_uchar);
    pub fn is_lag_trace(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_constr_type(lp: *mut lprec, rownr: libc::c_int,
                           con_type: libc::c_int)
     -> libc::c_uchar;
    pub fn get_constr_type(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_int;
    pub fn get_constr_value(lp: *mut lprec, rownr: libc::c_int,
                            count: libc::c_int,
                            primsolution: *mut libc::c_double,
                            nzindex: *mut libc::c_int)
     -> libc::c_double;
    pub fn is_constr_type(lp: *mut lprec, rownr: libc::c_int,
                          mask: libc::c_int)
     -> libc::c_uchar;
    pub fn get_str_constr_type(lp: *mut lprec,
                               con_type: libc::c_int)
     -> *mut libc::c_char;
    pub fn get_constr_class(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_int;
    pub fn get_str_constr_class(lp: *mut lprec,
                                con_class: libc::c_int)
     -> *mut libc::c_char;
    pub fn set_rh(lp: *mut lprec, rownr: libc::c_int,
                  value: libc::c_double) -> libc::c_uchar;
    pub fn get_rh(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn set_rh_range(lp: *mut lprec, rownr: libc::c_int,
                        deltavalue: libc::c_double)
     -> libc::c_uchar;
    pub fn get_rh_range(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn set_rh_vec(lp: *mut lprec, rh: *mut libc::c_double);
    pub fn str_set_rh_vec(lp: *mut lprec,
                          rh_string: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn add_column(lp: *mut lprec, column: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn add_columnex(lp: *mut lprec, count: libc::c_int,
                        column: *mut libc::c_double,
                        rowno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn str_add_column(lp: *mut lprec,
                          col_string: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_column(lp: *mut lprec, colnr: libc::c_int,
                      column: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_columnex(lp: *mut lprec, colnr: libc::c_int,
                        count: libc::c_int,
                        column: *mut libc::c_double,
                        rowno: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn column_in_lp(lp: *mut lprec, column: *mut libc::c_double)
     -> libc::c_int;
    pub fn get_columnex(lp: *mut lprec, colnr: libc::c_int,
                        column: *mut libc::c_double,
                        nzrow: *mut libc::c_int)
     -> libc::c_int;
    pub fn get_column(lp: *mut lprec, colnr: libc::c_int,
                      column: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn del_column(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn del_columnex(lp: *mut lprec, colmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn set_mat(lp: *mut lprec, rownr: libc::c_int,
                   colnr: libc::c_int,
                   value: libc::c_double)
     -> libc::c_uchar;
    pub fn get_mat(lp: *mut lprec, rownr: libc::c_int,
                   colnr: libc::c_int) -> libc::c_double;
    pub fn get_mat_byindex(lp: *mut lprec, matindex: libc::c_int,
                           isrow: libc::c_uchar,
                           adjustsign: libc::c_uchar)
     -> libc::c_double;
    pub fn get_nonzeros(lp: *mut lprec) -> libc::c_int;
    pub fn set_bounds_tighter(lp: *mut lprec,
                              tighten: libc::c_uchar);
    pub fn get_bounds(lp: *mut lprec, column: libc::c_int,
                      lower: *mut libc::c_double,
                      upper: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_bounds_tighter(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_upbo(lp: *mut lprec, colnr: libc::c_int,
                    value: libc::c_double)
     -> libc::c_uchar;
    pub fn get_upbo(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_double;
    pub fn set_lowbo(lp: *mut lprec, colnr: libc::c_int,
                     value: libc::c_double)
     -> libc::c_uchar;
    pub fn get_lowbo(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_double;
    pub fn set_bounds(lp: *mut lprec, colnr: libc::c_int,
                      lower: libc::c_double,
                      upper: libc::c_double)
     -> libc::c_uchar;
    pub fn set_unbounded(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn is_unbounded(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_int(lp: *mut lprec, colnr: libc::c_int,
                   must_be_int: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_int(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_binary(lp: *mut lprec, colnr: libc::c_int,
                      must_be_bin: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_binary(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_semicont(lp: *mut lprec, colnr: libc::c_int,
                        must_be_sc: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_semicont(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn is_negative(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_var_weights(lp: *mut lprec,
                           weights: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_var_priority(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_int;
    pub fn set_pseudocosts(lp: *mut lprec,
                           clower: *mut libc::c_double,
                           cupper: *mut libc::c_double,
                           updatelimit: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn get_pseudocosts(lp: *mut lprec,
                           clower: *mut libc::c_double,
                           cupper: *mut libc::c_double,
                           updatelimit: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn add_SOS(lp: *mut lprec, name: *mut libc::c_char,
                   sostype: libc::c_int,
                   priority: libc::c_int,
                   count: libc::c_int,
                   sosvars: *mut libc::c_int,
                   weights: *mut libc::c_double)
     -> libc::c_int;
    pub fn is_SOS_var(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_row_name(lp: *mut lprec, rownr: libc::c_int,
                        new_name: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn get_row_name(lp: *mut lprec, rownr: libc::c_int)
     -> *mut libc::c_char;
    pub fn get_origrow_name(lp: *mut lprec, rownr: libc::c_int)
     -> *mut libc::c_char;
    pub fn set_col_name(lp: *mut lprec, colnr: libc::c_int,
                        new_name: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn get_col_name(lp: *mut lprec, colnr: libc::c_int)
     -> *mut libc::c_char;
    pub fn get_origcol_name(lp: *mut lprec, colnr: libc::c_int)
     -> *mut libc::c_char;
    pub fn unscale(lp: *mut lprec);
    pub fn set_preferdual(lp: *mut lprec, dodual: libc::c_uchar);
    pub fn set_simplextype(lp: *mut lprec,
                           simplextype: libc::c_int);
    pub fn get_simplextype(lp: *mut lprec) -> libc::c_int;
    pub fn default_basis(lp: *mut lprec);
    pub fn set_basiscrash(lp: *mut lprec, mode: libc::c_int);
    pub fn get_basiscrash(lp: *mut lprec) -> libc::c_int;
    pub fn set_basisvar(lp: *mut lprec, basisPos: libc::c_int,
                        enteringCol: libc::c_int)
     -> libc::c_int;
    pub fn set_basis(lp: *mut lprec, bascolumn: *mut libc::c_int,
                     nonbasic: libc::c_uchar)
     -> libc::c_uchar;
    pub fn get_basis(lp: *mut lprec, bascolumn: *mut libc::c_int,
                     nonbasic: libc::c_uchar)
     -> libc::c_uchar;
    pub fn reset_basis(lp: *mut lprec);
    pub fn guess_basis(lp: *mut lprec,
                       guessvector: *mut libc::c_double,
                       basisvector: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn is_feasible(lp: *mut lprec, values: *mut libc::c_double,
                       threshold: libc::c_double)
     -> libc::c_uchar;
    pub fn solve(lp: *mut lprec) -> libc::c_int;
    pub fn time_elapsed(lp: *mut lprec) -> libc::c_double;
    pub fn put_bb_nodefunc(lp: *mut lprec, newnode: lphandleint_intfunc,
                           bbnodehandle: *mut libc::c_void);
    pub fn put_bb_branchfunc(lp: *mut lprec, newbranch: lphandleint_intfunc,
                             bbbranchhandle: *mut libc::c_void);
    pub fn put_abortfunc(lp: *mut lprec, newctrlc: lphandle_intfunc,
                         ctrlchandle: *mut libc::c_void);
    pub fn put_logfunc(lp: *mut lprec, newlog: lphandlestr_func,
                       loghandle: *mut libc::c_void);
    pub fn put_msgfunc(lp: *mut lprec, newmsg: lphandleint_func,
                       msghandle: *mut libc::c_void,
                       mask: libc::c_int);
    pub fn get_primal_solution(lp: *mut lprec,
                               pv: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_primal_solution(lp: *mut lprec,
                                   pv: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_dual_solution(lp: *mut lprec,
                             rc: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_dual_solution(lp: *mut lprec,
                                 rc: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_lambda(lp: *mut lprec, lambda: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_lambda(lp: *mut lprec,
                          lambda: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn read_MPS(filename: *mut libc::c_char,
                    options: libc::c_int) -> *mut lprec;
    pub fn read_mps(filename: *mut libc::FILE, options: libc::c_int)
     -> *mut lprec;
    pub fn read_freeMPS(filename: *mut libc::c_char,
                        options: libc::c_int) -> *mut lprec;
    pub fn read_freemps(filename: *mut libc::FILE, options: libc::c_int)
     -> *mut lprec;
    pub fn write_mps(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_MPS(lp: *mut lprec, output: *mut libc::FILE)
     -> libc::c_uchar;
    pub fn write_freemps(lp: *mut lprec,
                         filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_freeMPS(lp: *mut lprec, output: *mut libc::FILE)
     -> libc::c_uchar;
    pub fn write_lp(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_LP(lp: *mut lprec, output: *mut libc::FILE)
     -> libc::c_uchar;
    pub fn LP_readhandle(lp: *mut *mut lprec, filename: *mut libc::FILE,
                         verbose: libc::c_int,
                         lp_name: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_lp(filename: *mut libc::FILE, verbose: libc::c_int,
                   lp_name: *mut libc::c_char) -> *mut lprec;
    pub fn read_LP(filename: *mut libc::c_char,
                   verbose: libc::c_int,
                   lp_name: *mut libc::c_char) -> *mut lprec;
    pub fn write_basis(lp: *mut lprec, filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_basis(lp: *mut lprec, filename: *mut libc::c_char,
                      info: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn write_params(lp: *mut lprec, filename: *mut libc::c_char,
                        options: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn read_params(lp: *mut lprec, filename: *mut libc::c_char,
                       options: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn reset_params(lp: *mut lprec);
    pub fn print_lp(lp: *mut lprec);
    pub fn print_tableau(lp: *mut lprec);
    pub fn print_objective(lp: *mut lprec);
    pub fn print_solution(lp: *mut lprec, columns: libc::c_int);
    pub fn print_constraints(lp: *mut lprec, columns: libc::c_int);
    pub fn print_duals(lp: *mut lprec);
    pub fn print_scales(lp: *mut lprec);
    pub fn print_str(lp: *mut lprec, str: *mut libc::c_char);
    pub fn set_outputstream(lp: *mut lprec, stream: *mut libc::FILE);
    pub fn set_outputfile(lp: *mut lprec,
                          filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_verbose(lp: *mut lprec, verbose: libc::c_int);
    pub fn get_verbose(lp: *mut lprec) -> libc::c_int;
    pub fn set_timeout(lp: *mut lprec, sectimeout: libc::c_long);
    pub fn get_timeout(lp: *mut lprec) -> libc::c_long;
    pub fn set_print_sol(lp: *mut lprec, print_sol: libc::c_int);
    pub fn get_print_sol(lp: *mut lprec) -> libc::c_int;
    pub fn set_debug(lp: *mut lprec, debug: libc::c_uchar);
    pub fn is_debug(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_trace(lp: *mut lprec, trace: libc::c_uchar);
    pub fn is_trace(lp: *mut lprec) -> libc::c_uchar;
    pub fn print_debugdump(lp: *mut lprec,
                           filename: *mut libc::c_char)
     -> libc::c_uchar;
    pub fn set_anti_degen(lp: *mut lprec, anti_degen: libc::c_int);
    pub fn get_anti_degen(lp: *mut lprec) -> libc::c_int;
    pub fn is_anti_degen(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn set_presolve(lp: *mut lprec, presolvemode: libc::c_int,
                        maxloops: libc::c_int);
    pub fn get_presolve(lp: *mut lprec) -> libc::c_int;
    pub fn get_presolveloops(lp: *mut lprec) -> libc::c_int;
    pub fn is_presolve(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn get_orig_index(lp: *mut lprec, lp_index: libc::c_int)
     -> libc::c_int;
    pub fn get_lp_index(lp: *mut lprec, orig_index: libc::c_int)
     -> libc::c_int;
    pub fn set_maxpivot(lp: *mut lprec, max_num_inv: libc::c_int);
    pub fn get_maxpivot(lp: *mut lprec) -> libc::c_int;
    pub fn set_obj_bound(lp: *mut lprec, obj_bound: libc::c_double);
    pub fn get_obj_bound(lp: *mut lprec) -> libc::c_double;
    pub fn set_mip_gap(lp: *mut lprec, absolute: libc::c_uchar,
                       mip_gap: libc::c_double);
    pub fn get_mip_gap(lp: *mut lprec, absolute: libc::c_uchar)
     -> libc::c_double;
    pub fn set_bb_rule(lp: *mut lprec, bb_rule: libc::c_int);
    pub fn get_bb_rule(lp: *mut lprec) -> libc::c_int;
    pub fn set_var_branch(lp: *mut lprec, colnr: libc::c_int,
                          branch_mode: libc::c_int)
     -> libc::c_uchar;
    pub fn get_var_branch(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_int;
    pub fn is_infinite(lp: *mut lprec, value: libc::c_double)
     -> libc::c_uchar;
    pub fn set_infinite(lp: *mut lprec, infinite: libc::c_double);
    pub fn get_infinite(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsint(lp: *mut lprec, epsint: libc::c_double);
    pub fn get_epsint(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsb(lp: *mut lprec, epsb: libc::c_double);
    pub fn get_epsb(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsd(lp: *mut lprec, epsd: libc::c_double);
    pub fn get_epsd(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsel(lp: *mut lprec, epsel: libc::c_double);
    pub fn get_epsel(lp: *mut lprec) -> libc::c_double;
    pub fn set_epslevel(lp: *mut lprec, epslevel: libc::c_int)
     -> libc::c_uchar;
    pub fn set_scaling(lp: *mut lprec, scalemode: libc::c_int);
    pub fn get_scaling(lp: *mut lprec) -> libc::c_int;
    pub fn is_scalemode(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn is_scaletype(lp: *mut lprec, scaletype: libc::c_int)
     -> libc::c_uchar;
    pub fn is_integerscaling(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_scalelimit(lp: *mut lprec,
                          scalelimit: libc::c_double);
    pub fn get_scalelimit(lp: *mut lprec) -> libc::c_double;
    pub fn set_improve(lp: *mut lprec, improve: libc::c_int);
    pub fn get_improve(lp: *mut lprec) -> libc::c_int;
    pub fn set_pivoting(lp: *mut lprec, piv_rule: libc::c_int);
    pub fn get_pivoting(lp: *mut lprec) -> libc::c_int;
    pub fn set_partialprice(lp: *mut lprec, blockcount: libc::c_int,
                            blockstart: *mut libc::c_int,
                            isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn get_partialprice(lp: *mut lprec,
                            blockcount: *mut libc::c_int,
                            blockstart: *mut libc::c_int,
                            isrow: libc::c_uchar);
    pub fn set_multiprice(lp: *mut lprec,
                          multiblockdiv: libc::c_int)
     -> libc::c_uchar;
    pub fn get_multiprice(lp: *mut lprec, getabssize: libc::c_uchar)
     -> libc::c_int;
    pub fn is_use_names(lp: *mut lprec, isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn set_use_names(lp: *mut lprec, isrow: libc::c_uchar,
                         use_names: libc::c_uchar);
    pub fn get_nameindex(lp: *mut lprec, varname: *mut libc::c_char,
                         isrow: libc::c_uchar)
     -> libc::c_int;
    pub fn is_piv_mode(lp: *mut lprec, testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn is_piv_rule(lp: *mut lprec, rule: libc::c_int)
     -> libc::c_uchar;
    pub fn set_break_at_first(lp: *mut lprec,
                              break_at_first: libc::c_uchar);
    pub fn is_break_at_first(lp: *mut lprec) -> libc::c_uchar;
    pub fn set_bb_floorfirst(lp: *mut lprec,
                             bb_floorfirst: libc::c_int);
    pub fn get_bb_floorfirst(lp: *mut lprec) -> libc::c_int;
    pub fn set_bb_depthlimit(lp: *mut lprec,
                             bb_maxlevel: libc::c_int);
    pub fn get_bb_depthlimit(lp: *mut lprec) -> libc::c_int;
    pub fn set_break_at_value(lp: *mut lprec,
                              break_at_value: libc::c_double);
    pub fn get_break_at_value(lp: *mut lprec) -> libc::c_double;
    pub fn set_negrange(lp: *mut lprec, negrange: libc::c_double);
    pub fn get_negrange(lp: *mut lprec) -> libc::c_double;
    pub fn set_epsperturb(lp: *mut lprec,
                          epsperturb: libc::c_double);
    pub fn get_epsperturb(lp: *mut lprec) -> libc::c_double;
    pub fn set_epspivot(lp: *mut lprec, epspivot: libc::c_double);
    pub fn get_epspivot(lp: *mut lprec) -> libc::c_double;
    pub fn get_max_level(lp: *mut lprec) -> libc::c_int;
    pub fn get_total_nodes(lp: *mut lprec) -> libc::c_longlong;
    pub fn get_total_iter(lp: *mut lprec) -> libc::c_longlong;
    pub fn get_objective(lp: *mut lprec) -> libc::c_double;
    pub fn get_working_objective(lp: *mut lprec) -> libc::c_double;
    pub fn get_var_primalresult(lp: *mut lprec, index: libc::c_int)
     -> libc::c_double;
    pub fn get_var_dualresult(lp: *mut lprec, index: libc::c_int)
     -> libc::c_double;
    pub fn get_variables(lp: *mut lprec, var: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_variables(lp: *mut lprec,
                             var: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_constraints(lp: *mut lprec,
                           constr: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_constraints(lp: *mut lprec,
                               constr: *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_sensitivity_rhs(lp: *mut lprec,
                               duals: *mut libc::c_double,
                               dualsfrom: *mut libc::c_double,
                               dualstill: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_sensitivity_rhs(lp: *mut lprec,
                                   duals: *mut *mut libc::c_double,
                                   dualsfrom:
                                       *mut *mut libc::c_double,
                                   dualstill:
                                       *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_sensitivity_obj(lp: *mut lprec,
                               objfrom: *mut libc::c_double,
                               objtill: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_sensitivity_objex(lp: *mut lprec,
                                 objfrom: *mut libc::c_double,
                                 objtill: *mut libc::c_double,
                                 objfromvalue: *mut libc::c_double,
                                 objtillvalue: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_sensitivity_obj(lp: *mut lprec,
                                   objfrom:
                                       *mut *mut libc::c_double,
                                   objtill:
                                       *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn get_ptr_sensitivity_objex(lp: *mut lprec,
                                     objfrom:
                                         *mut *mut libc::c_double,
                                     objtill:
                                         *mut *mut libc::c_double,
                                     objfromvalue:
                                         *mut *mut libc::c_double,
                                     objtillvalue:
                                         *mut *mut libc::c_double)
     -> libc::c_uchar;
    pub fn set_solutionlimit(lp: *mut lprec, limit: libc::c_int);
    pub fn get_solutionlimit(lp: *mut lprec) -> libc::c_int;
    pub fn get_solutioncount(lp: *mut lprec) -> libc::c_int;
    pub fn get_Norig_rows(lp: *mut lprec) -> libc::c_int;
    pub fn get_Nrows(lp: *mut lprec) -> libc::c_int;
    pub fn get_Lrows(lp: *mut lprec) -> libc::c_int;
    pub fn get_Norig_columns(lp: *mut lprec) -> libc::c_int;
    pub fn get_Ncolumns(lp: *mut lprec) -> libc::c_int;
    pub fn MPS_readex(newlp: *mut *mut lprec,
                      userhandle: *mut libc::c_void,
                      read_modeldata: read_modeldata_func,
                      typeMPS: libc::c_int,
                      options: libc::c_int)
     -> libc::c_uchar;
    pub fn read_lpex(userhandle: *mut libc::c_void,
                     read_modeldata: read_modeldata_func,
                     verbose: libc::c_int,
                     lp_name: *mut libc::c_char) -> *mut lprec;
    pub fn write_lpex(lp: *mut lprec, userhandle: *mut libc::c_void,
                      write_modeldata: write_modeldata_func)
     -> libc::c_uchar;
    pub fn read_mpsex(userhandle: *mut libc::c_void,
                      read_modeldata: read_modeldata_func,
                      options: libc::c_int) -> *mut lprec;
    pub fn read_freempsex(userhandle: *mut libc::c_void,
                          read_modeldata: read_modeldata_func,
                          options: libc::c_int) -> *mut lprec;
    pub fn MPS_writefileex(lp: *mut lprec, typeMPS: libc::c_int,
                           userhandle: *mut libc::c_void,
                           write_modeldata: write_modeldata_func)
     -> libc::c_uchar;
    pub fn set_callbacks(lp: *mut lprec) -> libc::c_uchar;
    pub fn yieldformessages(lp: *mut lprec) -> libc::c_int;
    pub fn userabort(lp: *mut lprec, message: libc::c_int)
     -> libc::c_uchar;
    pub fn append_rows(lp: *mut lprec, deltarows: libc::c_int)
     -> libc::c_uchar;
    pub fn append_columns(lp: *mut lprec, deltacolumns: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_rows(lp: *mut lprec, delta: libc::c_int);
    pub fn inc_columns(lp: *mut lprec, delta: libc::c_int);
    pub fn init_rowcol_names(lp: *mut lprec) -> libc::c_uchar;
    pub fn inc_row_space(lp: *mut lprec, deltarows: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_col_space(lp: *mut lprec, deltacols: libc::c_int)
     -> libc::c_uchar;
    pub fn shift_rowcoldata(lp: *mut lprec, base: libc::c_int,
                            delta: libc::c_int, usedmap: *mut LLrec,
                            isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn shift_basis(lp: *mut lprec, base: libc::c_int,
                       delta: libc::c_int, usedmap: *mut LLrec,
                       isrow: libc::c_uchar)
     -> libc::c_uchar;
    pub fn shift_rowdata(lp: *mut lprec, base: libc::c_int,
                         delta: libc::c_int, usedmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn shift_coldata(lp: *mut lprec, base: libc::c_int,
                         delta: libc::c_int, usedmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn is_chsign(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_uchar;
    pub fn inc_lag_space(lp: *mut lprec, deltarows: libc::c_int,
                         ignoreMAT: libc::c_uchar)
     -> libc::c_uchar;
    pub fn make_lag(server: *mut lprec) -> *mut lprec;
    pub fn get_rh_upper(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn get_rh_lower(lp: *mut lprec, rownr: libc::c_int)
     -> libc::c_double;
    pub fn set_rh_upper(lp: *mut lprec, rownr: libc::c_int,
                        value: libc::c_double)
     -> libc::c_uchar;
    pub fn set_rh_lower(lp: *mut lprec, rownr: libc::c_int,
                        value: libc::c_double)
     -> libc::c_uchar;
    pub fn bin_count(lp: *mut lprec, working: libc::c_uchar)
     -> libc::c_int;
    pub fn MIP_count(lp: *mut lprec) -> libc::c_int;
    pub fn SOS_count(lp: *mut lprec) -> libc::c_int;
    pub fn GUB_count(lp: *mut lprec) -> libc::c_int;
    pub fn identify_GUB(lp: *mut lprec, mark: libc::c_uchar)
     -> libc::c_int;
    pub fn prepare_GUB(lp: *mut lprec) -> libc::c_int;
    pub fn refactRecent(lp: *mut lprec) -> libc::c_uchar;
    pub fn check_if_less(lp: *mut lprec, x: libc::c_double,
                         y: libc::c_double,
                         variable: libc::c_int)
     -> libc::c_uchar;
    pub fn feasiblePhase1(lp: *mut lprec, epsvalue: libc::c_double)
     -> libc::c_uchar;
    pub fn free_duals(lp: *mut lprec);
    pub fn initialize_solution(lp: *mut lprec,
                               shiftbounds: libc::c_uchar);
    pub fn recompute_solution(lp: *mut lprec,
                              shiftbounds: libc::c_uchar);
    pub fn verify_solution(lp: *mut lprec, reinvert: libc::c_uchar,
                           info: *mut libc::c_char)
     -> libc::c_int;
    pub fn check_solution(lp: *mut lprec, lastcolumn: libc::c_int,
                          solution: *mut libc::c_double,
                          upbo: *mut libc::c_double,
                          lowbo: *mut libc::c_double,
                          tolerance: libc::c_double)
     -> libc::c_int;
    pub fn is_fixedvar(lp: *mut lprec, variable: libc::c_int)
     -> libc::c_uchar;
    pub fn is_splitvar(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn set_action(actionvar: *mut libc::c_int,
                      actionmask: libc::c_int);
    pub fn clear_action(actionvar: *mut libc::c_int,
                        actionmask: libc::c_int);
    pub fn is_action(actionvar: libc::c_int,
                     testmask: libc::c_int)
     -> libc::c_uchar;
    pub fn is_bb_rule(lp: *mut lprec, bb_rule: libc::c_int)
     -> libc::c_uchar;
    pub fn is_bb_mode(lp: *mut lprec, bb_mask: libc::c_int)
     -> libc::c_uchar;
    pub fn get_piv_rule(lp: *mut lprec) -> libc::c_int;
    pub fn get_str_piv_rule(rule: libc::c_int)
     -> *mut libc::c_char;
    pub fn set_var_priority(lp: *mut lprec) -> libc::c_uchar;
    pub fn find_sc_bbvar(lp: *mut lprec, count: *mut libc::c_int)
     -> libc::c_int;
    pub fn find_sos_bbvar(lp: *mut lprec, count: *mut libc::c_int,
                          intsos: libc::c_uchar)
     -> libc::c_int;
    pub fn find_int_bbvar(lp: *mut lprec, count: *mut libc::c_int,
                          BB: *mut BBrec,
                          isfeasible: *mut libc::c_uchar)
     -> libc::c_int;
    pub fn compute_dualslacks(lp: *mut lprec, target: libc::c_int,
                              dvalues: *mut *mut libc::c_double,
                              nzdvalues: *mut *mut libc::c_int,
                              dosum: libc::c_uchar)
     -> libc::c_double;
    pub fn solution_is_int(lp: *mut lprec, index: libc::c_int,
                           checkfixed: libc::c_uchar)
     -> libc::c_uchar;
    pub fn bb_better(lp: *mut lprec, target: libc::c_int,
                     mode: libc::c_int) -> libc::c_uchar;
    pub fn construct_solution(lp: *mut lprec,
                              target: *mut libc::c_double);
    pub fn transfer_solution_var(lp: *mut lprec,
                                 uservar: libc::c_int);
    pub fn construct_duals(lp: *mut lprec) -> libc::c_uchar;
    pub fn construct_sensitivity_duals(lp: *mut lprec)
     -> libc::c_uchar;
    pub fn construct_sensitivity_obj(lp: *mut lprec)
     -> libc::c_uchar;
    pub fn add_GUB(lp: *mut lprec, name: *mut libc::c_char,
                   priority: libc::c_int,
                   count: libc::c_int,
                   sosvars: *mut libc::c_int)
     -> libc::c_int;
    pub fn push_basis(lp: *mut lprec, basisvar: *mut libc::c_int,
                      isbasic: *mut libc::c_uchar,
                      islower: *mut libc::c_uchar) -> *mut basisrec;
    pub fn compare_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn restore_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn pop_basis(lp: *mut lprec, restore: libc::c_uchar)
     -> libc::c_uchar;
    pub fn is_BasisReady(lp: *mut lprec) -> libc::c_uchar;
    pub fn is_slackbasis(lp: *mut lprec) -> libc::c_uchar;
    pub fn verify_basis(lp: *mut lprec) -> libc::c_uchar;
    pub fn unload_basis(lp: *mut lprec, restorelast: libc::c_uchar)
     -> libc::c_int;
    pub fn perturb_bounds(lp: *mut lprec, perturbed: *mut BBrec,
                          doRows: libc::c_uchar,
                          doCols: libc::c_uchar,
                          includeFIXED: libc::c_uchar)
     -> libc::c_int;
    pub fn validate_bounds(lp: *mut lprec,
                           upbo: *mut libc::c_double,
                           lowbo: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn impose_bounds(lp: *mut lprec, upbo: *mut libc::c_double,
                         lowbo: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn unload_BB(lp: *mut lprec) -> libc::c_int;
    pub fn feasibilityOffset(lp: *mut lprec, isdual: libc::c_uchar)
     -> libc::c_double;
    pub fn isP1extra(lp: *mut lprec) -> libc::c_uchar;
    pub fn get_refactfrequency(lp: *mut lprec,
                               _final: libc::c_uchar)
     -> libc::c_double;
    pub fn findBasicFixedvar(lp: *mut lprec, afternr: libc::c_int,
                             slacksonly: libc::c_uchar)
     -> libc::c_int;
    pub fn isBasisVarFeasible(lp: *mut lprec, tol: libc::c_double,
                              basis_row: libc::c_int)
     -> libc::c_uchar;
    pub fn isPrimalFeasible(lp: *mut lprec, tol: libc::c_double,
                            infeasibles: *mut libc::c_int,
                            feasibilitygap: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn isDualFeasible(lp: *mut lprec, tol: libc::c_double,
                          boundflips: *mut libc::c_int,
                          infeasibles: *mut libc::c_int,
                          feasibilitygap: *mut libc::c_double)
     -> libc::c_uchar;
    pub fn preprocess(lp: *mut lprec) -> libc::c_int;
    pub fn postprocess(lp: *mut lprec);
    pub fn performiteration(lp: *mut lprec, rownr: libc::c_int,
                            varin: libc::c_int,
                            theta: libc::c_double,
                            primal: libc::c_uchar,
                            allowminit: libc::c_uchar,
                            prow: *mut libc::c_double,
                            nzprow: *mut libc::c_int,
                            pcol: *mut libc::c_double,
                            nzpcol: *mut libc::c_int,
                            boundswaps: *mut libc::c_int)
     -> libc::c_uchar;
    pub fn transfer_solution(lp: *mut lprec,
                             dofinal: libc::c_uchar);
    pub fn scaled_floor(lp: *mut lprec, colnr: libc::c_int,
                        value: libc::c_double,
                        epsscale: libc::c_double)
     -> libc::c_double;
    pub fn scaled_ceil(lp: *mut lprec, colnr: libc::c_int,
                       value: libc::c_double,
                       epsscale: libc::c_double)
     -> libc::c_double;
    pub fn varmap_lock(lp: *mut lprec);
    pub fn varmap_clear(lp: *mut lprec);
    pub fn varmap_canunlock(lp: *mut lprec) -> libc::c_uchar;
    pub fn varmap_addconstraint(lp: *mut lprec);
    pub fn varmap_addcolumn(lp: *mut lprec);
    pub fn varmap_delete(lp: *mut lprec, base: libc::c_int,
                         delta: libc::c_int, varmap: *mut LLrec);
    pub fn varmap_compact(lp: *mut lprec, prev_rows: libc::c_int,
                          prev_cols: libc::c_int);
    pub fn varmap_validate(lp: *mut lprec, varno: libc::c_int)
     -> libc::c_uchar;
    pub fn del_varnameex(lp: *mut lprec, namelist: *mut *mut hashelem,
                         items: libc::c_int, ht: *mut hashtable,
                         varnr: libc::c_int, varmap: *mut LLrec)
     -> libc::c_uchar;
    pub fn init_pseudocost(lp: *mut lprec, pseudotype: libc::c_int)
     -> *mut BBPSrec;
    pub fn free_pseudocost(lp: *mut lprec);
    pub fn get_pseudorange(pc: *mut BBPSrec, mipvar: libc::c_int,
                           varcode: libc::c_int)
     -> libc::c_double;
    pub fn update_pseudocost(pc: *mut BBPSrec, mipvar: libc::c_int,
                             varcode: libc::c_int,
                             capupper: libc::c_uchar,
                             varsol: libc::c_double);
    pub fn get_pseudobranchcost(pc: *mut BBPSrec,
                                mipvar: libc::c_int,
                                dofloor: libc::c_uchar)
     -> libc::c_double;
    pub fn get_pseudonodecost(pc: *mut BBPSrec, mipvar: libc::c_int,
                              vartype: libc::c_int,
                              varsol: libc::c_double)
     -> libc::c_double;
    pub fn set_OF_override(lp: *mut lprec,
                           ofVector: *mut libc::c_double);
    pub fn set_OF_p1extra(lp: *mut lprec, p1extra: libc::c_double);
    pub fn unset_OF_p1extra(lp: *mut lprec);
    pub fn modifyOF1(lp: *mut lprec, index: libc::c_int,
                     ofValue: *mut libc::c_double,
                     mult: libc::c_double)
     -> libc::c_uchar;
    pub fn get_OF_active(lp: *mut lprec, varnr: libc::c_int,
                         mult: libc::c_double)
     -> libc::c_double;
    pub fn is_OF_nz(lp: *mut lprec, colnr: libc::c_int)
     -> libc::c_uchar;
    pub fn get_basisOF(lp: *mut lprec, coltarget: *mut libc::c_int,
                       crow: *mut libc::c_double,
                       colno: *mut libc::c_int)
     -> libc::c_int;
    pub fn get_basiscolumn(lp: *mut lprec, j: libc::c_int,
                           rn: *mut libc::c_int,
                           bj: *mut libc::c_double)
     -> libc::c_int;
    pub fn obtain_column(lp: *mut lprec, varin: libc::c_int,
                         pcol: *mut libc::c_double,
                         nzlist: *mut libc::c_int,
                         maxabs: *mut libc::c_int)
     -> libc::c_int;
    pub fn compute_theta(lp: *mut lprec, rownr: libc::c_int,
                         theta: *mut libc::c_double,
                         isupbound: libc::c_int,
                         HarrisScalar: libc::c_double,
                         primal: libc::c_uchar)
     -> libc::c_int;
    pub fn findBasisPos(lp: *mut lprec, notint: libc::c_int,
                        var_basic: *mut libc::c_int)
     -> libc::c_int;
    pub fn check_degeneracy(lp: *mut lprec,
                            pcol: *mut libc::c_double,
                            degencount: *mut libc::c_int)
     -> libc::c_uchar;
}
